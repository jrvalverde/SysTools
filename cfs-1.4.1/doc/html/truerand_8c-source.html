<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>CFS: truerand.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>truerand.c</h1><a href="truerand_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> *      Almost "true" random numbers (very nearly uniform)</span>
00003 <span class="comment"> *      Based on code by D. P. Mitchell</span>
00004 <span class="comment"> *      Modified by Matt Blaze 7/95, 11/96</span>
00005 <span class="comment"> *      Version 2.1</span>
00006 <span class="comment"> *</span>
00007 <span class="comment"> *      This is completely unsupported software.</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> */</span>
00010 <span class="comment">/*</span>
00011 <span class="comment"> * The authors of this software are Don Mitchell and Matt Blaze.</span>
00012 <span class="comment"> *              Copyright (c) 1995, 1996 by AT&amp;T.</span>
00013 <span class="comment"> * Permission to use, copy, and modify this software without fee</span>
00014 <span class="comment"> * is hereby granted, provided that this entire notice is included in</span>
00015 <span class="comment"> * all copies of any software which is or includes a copy or</span>
00016 <span class="comment"> * modification of this software and in all copies of the supporting</span>
00017 <span class="comment"> * documentation for such software.</span>
00018 <span class="comment"> </span>
00019 <span class="comment"> *</span>
00020 <span class="comment"> * This software may be subject to United States export controls.</span>
00021 <span class="comment"> *</span>
00022 <span class="comment"> * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR IMPLIED</span>
00023 <span class="comment"> * WARRANTY.  IN PARTICULAR, NEITHER THE AUTHORS NOR AT&amp;T MAKE ANY</span>
00024 <span class="comment"> * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY</span>
00025 <span class="comment"> * OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.</span>
00026 <span class="comment"> */</span>
00027 
00028 <span class="comment">/*</span>
00029 <span class="comment"> * Truerand is a dubious, unproven hack for generating "true" random</span>
00030 <span class="comment"> * numbers in software.  It is at best a good "method of last resort"</span>
00031 <span class="comment"> * for generating key material in environments where there is no (or</span>
00032 <span class="comment"> * only an insufficient) source of better-understood randomness.  It</span>
00033 <span class="comment"> * can also be used to augment unreliable randomness sources (such as</span>
00034 <span class="comment"> * input from a human operator).</span>
00035 <span class="comment"> *</span>
00036 <span class="comment"> * The basic idea behind truerand is that between clock "skew" and</span>
00037 <span class="comment"> * various hard-to-predict OS event arrivals, counting a tight loop</span>
00038 <span class="comment"> * will yield a little bit (maybe one bit or so) of "good" randomness</span>
00039 <span class="comment"> * per interval clock tick.  This seems to work well in practice even</span>
00040 <span class="comment"> * on unloaded machines.  If there is a human operator at the machine,</span>
00041 <span class="comment"> * you should augment trand with other measurements, such as keyboard</span>
00042 <span class="comment"> * event timing.  On server machines (e.g., where you need to generate</span>
00043 <span class="comment"> * a Diffie-Hellman secret but have no operator to type keys) trand</span>
00044 <span class="comment"> * alone may (or may not) be sufficient.</span>
00045 <span class="comment"> *</span>
00046 <span class="comment"> * Because the randomness source is not well-understood, I've made</span>
00047 <span class="comment"> * fairly conservative assumptions about how much randomness can be</span>
00048 <span class="comment"> * extracted in any given interval.  Based on a cursory analysis of</span>
00049 <span class="comment"> * the BSD kernel, there seem to be about 100-200 bits of unexposed</span>
00050 <span class="comment"> * "state" that changes each time a system call occurs and that affect</span>
00051 <span class="comment"> * the exact handling of interrupt scheduling, plus a great deal of</span>
00052 <span class="comment"> * slower-changing but still hard-to-model state based on, e.g., the</span>
00053 <span class="comment"> * process table, the VM state, etc.  There is no proof or guarantee</span>
00054 <span class="comment"> * that some of this state couldn't be easily reconstructed, modeled</span>
00055 <span class="comment"> * or influenced by an attacker, however, so we keep a large margin</span>
00056 <span class="comment"> * for error.  The truerand API assumes only 0.3 bits of entropy per</span>
00057 <span class="comment"> * interval interrupt, amortized over 24 intervals and whitened with</span>
00058 <span class="comment"> * SHA.</span>
00059 <span class="comment"> *</span>
00060 <span class="comment"> * The trurand API is in randbyte.c, and consists of trand8(),</span>
00061 <span class="comment"> * trand16(), and trand32().  Do not use raw_truerand() directly.</span>
00062 <span class="comment"> * </span>
00063 <span class="comment"> * WARNING: depending on the particular platform, raw_truerand()</span>
00064 <span class="comment"> * output may be biased or correlated.  In general, you can expect no</span>
00065 <span class="comment"> * more than 8-16 bits of "pseudo-entropy" out of each 32 bit word.</span>
00066 <span class="comment"> * Always run the output through a good post-whitening function (like</span>
00067 <span class="comment"> * SHA, MD5 or DES or whatever) before using it to generate key</span>
00068 <span class="comment"> * material.  The API does this for you, providing 8, 16, and 32 bit</span>
00069 <span class="comment"> * properly "whitened" random numbers (trand8(), trand16(), and</span>
00070 <span class="comment"> * trand32(), respectively).  Use the trand calls instead of calling</span>
00071 <span class="comment"> * raw_truerand() directly.</span>
00072 <span class="comment"> *</span>
00073 <span class="comment"> * Test truerand on your own platform before fielding a system based</span>
00074 <span class="comment"> * on this software or these techniques.</span>
00075 <span class="comment"> *</span>
00076 <span class="comment"> * This software seems to work well (at 10 or so bits per</span>
00077 <span class="comment"> * raw_truerand() call) on a Sun Sparc-20 under SunOS 4.1.3 and on a</span>
00078 <span class="comment"> * P100 under BSDI 2.0.  You're on your own elsewhere.</span>
00079 <span class="comment"> *</span>
00080 <span class="comment"> * This version of truerand doesn't clobber the ITIMER, so any</span>
00081 <span class="comment"> * scheduled alarms will still occur (though alarms cannot occur while</span>
00082 <span class="comment"> * raw_truerand is running and will be delayed by about 250ms per</span>
00083 <span class="comment"> * raw_truerand call.</span>
00084 <span class="comment"> */</span>
00085 
00086 <span class="preprocessor">#include &lt;signal.h&gt;</span>
00087 <span class="preprocessor">#include &lt;setjmp.h&gt;</span>
00088 <span class="preprocessor">#include &lt;sys/time.h&gt;</span>
00089 <span class="preprocessor">#include &lt;math.h&gt;</span>
00090 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00091 
00092 <span class="keyword">static</span> jmp_buf env;
00093 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> count;
00094 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> ocount;
00095 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> buffer;
00096 
00097 <span class="keyword">static</span> <span class="keywordtype">int</span>
00098 tick()
00099 {
00100         <span class="keyword">struct </span>itimerval it;
00101 
00102         timerclear(&amp;it.it_interval);
00103         it.it_value.tv_sec = 0;
00104         it.it_value.tv_usec = 16665;
00105         <span class="keywordflow">if</span> (setitimer(ITIMER_REAL, &amp;it, NULL) &lt; 0)
00106                 perror(<span class="stringliteral">"tick"</span>);
00107 }
00108 
00109 <span class="keyword">static</span> <span class="keywordtype">void</span>
00110 interrupt()
00111 {
00112         <span class="keywordflow">if</span> (count)
00113                 longjmp(env, 1);
00114         (<span class="keywordtype">void</span>) signal(SIGALRM, interrupt);
00115         tick();
00116 }
00117 
00118 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>
00119 roulette()
00120 {
00121         <span class="keywordflow">if</span> (setjmp(env))
00122                 <span class="keywordflow">return</span> count;
00123         (<span class="keywordtype">void</span>) signal(SIGALRM, interrupt);
00124         count = 0;
00125         tick();
00126         <span class="keywordflow">for</span> (;;)
00127                 count++;        <span class="comment">/* about 1 MHz on VAX 11/780 */</span>
00128 }
00129 
00130 <span class="comment">/*</span>
00131 <span class="comment"> * basic interface to 32 bit truerand.</span>
00132 <span class="comment"> * note that any scheduled SIGALRM will be delayed by about .3 secs.</span>
00133 <span class="comment"> */</span>
00134 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>
<a name="l00135"></a><a class="code" href="truerand_8c.html#a7">00135</a> <a class="code" href="truerand_8c.html#a7">raw_truerand</a>()
00136 {
00137         void (*oldalrm)();
00138         <span class="keyword">struct </span>itimerval it;
00139         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> counts[12];
00140         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *<a class="code" href="shs_8h.html#a0">qshs</a>();
00141         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *r;
00142         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="cfs__fh_8c.html#a34">buf</a>;
00143         <span class="keywordtype">int</span> i;
00144 
00145         getitimer(ITIMER_REAL, &amp;it);
00146         oldalrm = signal(SIGALRM, SIG_IGN);
00147         <span class="keywordflow">for</span> (i=0; i&lt;12; i++) {
00148                 counts[i]=0;
00149                 <span class="keywordflow">while</span> ((counts[i] += roulette()) &lt; 512)
00150                         ;
00151         }
00152         signal(SIGALRM, oldalrm);
00153         setitimer(ITIMER_REAL, &amp;it, NULL);
00154 
00155         r = <a class="code" href="shs_8h.html#a0">qshs</a>(counts,<span class="keyword">sizeof</span>(counts));
00156         <a class="code" href="cfs__fh_8c.html#a34">buf</a> = *((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *) r);
00157 
00158         <span class="keywordflow">return</span> <a class="code" href="cfs__fh_8c.html#a34">buf</a>;
00159 }
00160 
00161 <span class="keywordtype">int</span>
00162 <a class="code" href="truerand_8c.html#a8">raw_n_truerand</a>(n)
00163 <span class="keywordtype">int</span> <a class="code" href="shs_8c.html#a29">n</a>;
00164 {
00165         <span class="keywordtype">int</span> slop, v;
00166 
00167         slop = 0x7FFFFFFF % <a class="code" href="shs_8c.html#a29">n</a>;
00168         <span class="keywordflow">do</span> {
00169                 v = <a class="code" href="truerand_8c.html#a7">raw_truerand</a>() &gt;&gt; 1;
00170         } <span class="keywordflow">while</span> (v &lt;= slop);
00171         <span class="keywordflow">return</span> v % <a class="code" href="shs_8c.html#a29">n</a>;
00172 }
00173 
00174 
00175 
00176 <span class="comment">/*</span>
00177 <span class="comment"> *      Random byte interface to truerand()</span>
00178 <span class="comment"> *      Matt Blaze 9/95</span>
00179 <span class="comment"> *      8, 16, 32 really random bits, at about .35 bits per clock</span>
00180 <span class="comment"> *      interrupt.</span>
00181 <span class="comment"> *</span>
00182 <span class="comment"> *      usage: </span>
00183 <span class="comment"> *              unsigned char r8;</span>
00184 <span class="comment"> *              unsigned short r16;</span>
00185 <span class="comment"> *              unsigned long r32;</span>
00186 <span class="comment"> *              unsigned long trand8(), trand16(), trand32();</span>
00187 <span class="comment"> *              r8=trand8();</span>
00188 <span class="comment"> *              r16=trand16();</span>
00189 <span class="comment"> *              r32=trand32();</span>
00190 <span class="comment"> *</span>
00191 <span class="comment"> *      randbyte() is the same as trand8().</span>
00192 <span class="comment"> *      trand8() takes about .3 seconds on most machines.</span>
00193 <span class="comment"> */</span>
00194 <span class="comment">/*</span>
00195 <span class="comment"> * The author of this software is Matt Blaze.</span>
00196 <span class="comment"> *              Copyright (c) 1995 by AT&amp;T.</span>
00197 <span class="comment"> * Permission to use, copy, and modify this software without fee</span>
00198 <span class="comment"> * is hereby granted, provided that this entire notice is included in</span>
00199 <span class="comment"> * all copies of any software which is or includes a copy or</span>
00200 <span class="comment"> * modification of this software and in all copies of the supporting</span>
00201 <span class="comment"> * documentation for such software.</span>
00202 <span class="comment"> *</span>
00203 <span class="comment"> * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR IMPLIED</span>
00204 <span class="comment"> * WARRANTY.  IN PARTICULAR, NEITHER THE AUTHORS NOR AT&amp;T MAKE ANY</span>
00205 <span class="comment"> * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY</span>
00206 <span class="comment"> * OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.</span>
00207 <span class="comment"> */</span>
00208  
00209 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00210 <span class="preprocessor">#include &lt;sys/stat.h&gt;</span>
00211 <span class="preprocessor">#include &lt;fcntl.h&gt;</span>
00212 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
00213 
00214 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> randbyte()
00215 {
00216 <span class="preprocessor">#ifdef DEV_RANDOM</span>
00217 <span class="preprocessor"></span>        <span class="comment">/* First try to read from /dev/random */</span>
00218         <span class="keywordtype">int</span> dev_random;
00219         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> value;
00220         
00221         <span class="keywordflow">if</span> ((dev_random = open(<span class="stringliteral">"/dev/random"</span>, O_RDONLY)) != -1) {
00222             <span class="comment">/* /dev/random opened, use it */</span>
00223             <span class="keywordflow">if</span> (read(dev_random, &amp;value, <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)) == 
00224                 <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)) {
00225                 <span class="comment">/* OK */</span>
00226                 close(dev_random);
00227                 <span class="keywordflow">return</span> value;
00228             }
00229         }
00230         close(dev_random);
00231         <span class="comment">/* else fall back to default method */</span>
00232 <span class="preprocessor">#endif</span>
00233 <span class="preprocessor"></span><span class="preprocessor">#if defined(PRNGD) || defined(EGD)</span>
00234 <span class="preprocessor"></span>        <span class="comment">/* First try to read from /dev/egd-pool */</span>
00235                 
00236         <span class="keywordflow">if</span> ((dev_random = open(<span class="stringliteral">"/dev/egd-pool"</span>, O_RDONLY)) != -1) {
00237             <span class="comment">/* /dev/random opened, use it */</span>
00238             <span class="keywordflow">if</span> (read(dev_random, &amp;value, <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)) == 
00239                 <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)) {
00240                 <span class="comment">/* OK */</span>
00241                 close(dev_random);
00242                 <span class="keywordflow">return</span> value;
00243             }
00244         }
00245         close(dev_random);
00246         <span class="comment">/* else fall back to default method */</span>
00247 <span class="preprocessor">#endif</span>
00248 <span class="preprocessor"></span>    {
00249         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="truerand_8c.html#a7">raw_truerand</a>();
00250         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *<a class="code" href="shs_8h.html#a0">qshs</a>();
00251         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> r[2];
00252         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *<a class="code" href="cfs__fh_8c.html#a0">hash</a>;
00253 
00254         r[0]=<a class="code" href="truerand_8c.html#a7">raw_truerand</a>(); r[1]=<a class="code" href="truerand_8c.html#a7">raw_truerand</a>();
00255         <a class="code" href="cfs__fh_8c.html#a0">hash</a> = <a class="code" href="shs_8h.html#a0">qshs</a>(r,<span class="keyword">sizeof</span>(r));
00256         <span class="keywordflow">return</span> ((<span class="keywordtype">int</span>) (*hash)) &amp; 0xff;
00257     }
00258 }
00259 
00260 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> trand8()
00261 {
00262         <span class="keywordflow">return</span> randbyte();
00263 }
00264 
00265 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> trand16()
00266 {
00267         <span class="keywordflow">return</span> randbyte() ^ (randbyte()&lt;&lt;8);
00268 }
00269 
00270 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> trand32()
00271 {
00272         <span class="keywordflow">return</span> randbyte() ^ (randbyte()&lt;&lt;8)
00273                 ^ (randbyte()&lt;&lt;16) ^ (randbyte()&lt;&lt;24);
00274 }
00275 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Tue Jun 15 09:59:03 2004 for CFS by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>

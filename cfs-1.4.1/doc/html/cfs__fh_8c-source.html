<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>CFS: cfs_fh.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>cfs_fh.c</h1><a href="cfs__fh_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> * The author of this software is Matt Blaze.</span>
00003 <span class="comment"> *              Copyright (c) 1992, 1993, 1994 by AT&amp;T.</span>
00004 <span class="comment"> * Permission to use, copy, and modify this software without fee</span>
00005 <span class="comment"> * is hereby granted, provided that this entire notice is included in</span>
00006 <span class="comment"> * all copies of any software which is or includes a copy or</span>
00007 <span class="comment"> * modification of this software and in all copies of the supporting</span>
00008 <span class="comment"> * documentation for such software.</span>
00009 <span class="comment"> *</span>
00010 <span class="comment"> * This software is subject to United States export controls.</span>
00011 <span class="comment"> *</span>
00012 <span class="comment"> * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR IMPLIED</span>
00013 <span class="comment"> * WARRANTY.  IN PARTICULAR, NEITHER THE AUTHORS NOR AT&amp;T MAKE ANY</span>
00014 <span class="comment"> * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY</span>
00015 <span class="comment"> * OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.</span>
00016 <span class="comment"> */</span>
00017 
00018 <span class="comment">/*</span>
00019 <span class="comment"> * cfs file handle support - 1.4</span>
00020 <span class="comment"> *  local file system interface</span>
00021 <span class="comment"> */</span>
00022 
00023 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00024 <span class="preprocessor">#include &lt;sys/file.h&gt;</span>
00025 <span class="preprocessor">#include &lt;sys/stat.h&gt;</span>
00026 <span class="preprocessor">#include &lt;sys/errno.h&gt;</span>
00027 <span class="preprocessor">#ifdef NeXT</span>
00028 <span class="preprocessor"></span><span class="preprocessor">#include &lt;sys/dir.h&gt;</span>
00029 <span class="preprocessor">#define dirent direct</span>
00030 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00031 <span class="preprocessor"></span><span class="preprocessor">#include &lt;dirent.h&gt;</span>
00032 <span class="preprocessor">#endif</span>
00033 <span class="preprocessor"></span><span class="preprocessor">#include &lt;rpc/rpc.h&gt;</span>
00034 <span class="preprocessor">#include &lt;fcntl.h&gt;</span>
00035 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00036 <span class="preprocessor">#ifdef hpux</span>
00037 <span class="preprocessor"></span><span class="preprocessor">#define NO_UTIMES</span>
00038 <span class="preprocessor"></span><span class="preprocessor">#include &lt;time.h&gt;</span>
00039 <span class="preprocessor">#endif</span>
00040 <span class="preprocessor"></span><span class="preprocessor">#ifdef  ultrix</span>
00041 <span class="preprocessor"></span><span class="preprocessor">#include &lt;time.h&gt;</span>
00042 <span class="preprocessor">#endif  </span><span class="comment">/* ultrix */</span>
00043 <span class="preprocessor">#ifdef NO_UTIMES</span>
00044 <span class="preprocessor"></span><span class="preprocessor">#include &lt;utime.h&gt;</span>
00045 <span class="preprocessor">#endif</span>
00046 <span class="preprocessor"></span>
00047 <span class="preprocessor">#include "nfsproto.h"</span>
00048 <span class="preprocessor">#include "admproto.h"</span>
00049 <span class="preprocessor">#include "<a class="code" href="cfs_8h.html">cfs.h</a>"</span>
00050 
00051 <span class="preprocessor">#ifdef NO_UTIMES</span>
00052 <span class="preprocessor"></span><span class="comment">/* simulate utimes with utime */</span>
00053 <span class="keywordtype">int</span> utimes(s,tv)
00054 <span class="keywordtype">char</span> *<a class="code" href="cfs__fh_8c.html#a0">s</a>;
00055 <span class="keyword">struct </span>timeval tv[2];
00056 {
00057     <span class="keyword">struct </span>utimbuf ut;
00058     ut.actime = tv[0].tv_sec;
00059     ut.modtime = tv[1].tv_sec;
00060     <span class="keywordflow">return</span> utime(s,&amp;ut);
00061 }
00062 <span class="preprocessor">#endif</span>
00063 <span class="preprocessor"></span>
<a name="l00064"></a><a class="code" href="cfs__fh_8c.html#a0">00064</a> <span class="preprocessor">#define hash(x) ((u_long)((x)&amp;HMASK))</span>
<a name="l00065"></a><a class="code" href="cfs__fh_8c.html#a3">00065</a> <span class="preprocessor"></span><span class="keywordtype">int</span> <a class="code" href="cfs__fh_8c.html#a3">inst</a> = 0;<span class="comment">/* starting point */</span>
<a name="l00066"></a><a class="code" href="cfs__fh_8c.html#a4">00066</a> <a class="code" href="structinstance.html">instance</a> *<a class="code" href="cfs_8h.html#a35">instances</a>[<a class="code" href="cfs_8h.html#a5">NINSTANCES</a>];
00067 
<a name="l00068"></a><a class="code" href="cfs__fh_8c.html#a1">00068</a> <span class="preprocessor">#define MAXFDS 12</span>
<a name="l00069"></a><a class="code" href="cfs__fh_8c.html#a5">00069</a> <span class="preprocessor"></span><a class="code" href="structfdcache.html">fdcache</a> *<a class="code" href="cfs__fh_8c.html#a5">fds</a>=NULL;
<a name="l00070"></a><a class="code" href="cfs__fh_8c.html#a6">00070</a> <span class="keywordtype">int</span> <a class="code" href="cfs__fh_8c.html#a6">nfds</a>=0;     <span class="comment">/* number of open fd's currently in cache */</span>
00071 
<a name="l00072"></a><a class="code" href="cfs__fh_8c.html#a7">00072</a> <span class="keywordtype">int</span> <a class="code" href="cfs_8h.html#a30">cfserrno</a>=NFS_OK;
00073 
00074 <span class="comment">/*</span>
00075 <span class="comment"> * get an encrypted block from fd, which damn well better be valid</span>
00076 <span class="comment"> */</span>
00077 <span class="keywordtype">int</span>
00078 <a class="code" href="cfs__fh_8c.html#a38">readblock</a>(blk,fd,offset,len,key,vect)
00079      <span class="keywordtype">char</span> *blk;     <span class="comment">/* data */</span>
00080      <span class="keywordtype">int</span> <a class="code" href="cfs__fh_8c.html#a8">fd</a>;        <span class="comment">/* fd */</span>
00081      u_long <a class="code" href="cfs__fh_8c.html#a9">offset</a>; <span class="comment">/* offset from byte zero */</span>
00082      u_long <a class="code" href="cfs__fh_8c.html#a0">len</a>;    <span class="comment">/* blk len */</span>
00083      <a class="code" href="structcfskey.html">cfskey</a> *<a class="code" href="mcg_8c.html#a0">key</a>;     <span class="comment">/* des key */</span>
00084      <span class="keywordtype">char</span> *<a class="code" href="cfs__fh_8c.html#a12">vect</a>;  <span class="comment">/* perturbation vector */</span>
00085 {
00086         u_long begin;
00087         u_long fronterr, totlen,datalen;
00088         <span class="keywordtype">int</span> iolen;
00089         <span class="keywordtype">int</span> readmore=0;
00090         <span class="keywordtype">int</span> userbytes;
00091         <span class="keywordtype">char</span> <a class="code" href="cfs__fh_8c.html#a34">buf</a>[8208]; <span class="comment">/* big enough, may not even need it */</span>
00092 
00093         <span class="comment">/* first, normalize to the proper boundries */</span>
00094         fronterr = <a class="code" href="cfs__fh_8c.html#a9">offset</a>&amp;(<a class="code" href="cfs_8h.html#a6">CFSBLOCK</a>-1);
00095         datalen=<a class="code" href="cfs__fh_8c.html#a0">len</a>+fronterr;
00096         begin=<a class="code" href="cfs__fh_8c.html#a9">offset</a>-fronterr;
00097         totlen=vtod(datalen);
00098         <span class="comment">/* now begin and totlen are what we do the actual i/o on */</span>
00099         <span class="keywordflow">if</span> (totlen&gt;8208)
00100                 <span class="keywordflow">return</span> -1;      <span class="comment">/* shouldn't happen */</span>
00101         <span class="keywordflow">if</span> (lseek(<a class="code" href="cfs__fh_8c.html#a8">fd</a>,(off_t)begin,L_SET)&lt;0)
00102                 <span class="keywordflow">return</span> -1;
00103         <span class="comment">/* note that we are violating standard unix semantics here - we have</span>
00104 <span class="comment">           no way to distinguish between zeros in the encrypted file and</span>
00105 <span class="comment">           holes in the file, which should be returned to the user as</span>
00106 <span class="comment">           zeros.  This could be fixed by detecting that we're creating</span>
00107 <span class="comment">           holes at write time and filling w/ encrypted zeros, but that</span>
00108 <span class="comment">           violates other semantics. */</span>
00109         <span class="keywordflow">if</span> ((iolen=read(<a class="code" href="cfs__fh_8c.html#a8">fd</a>,<a class="code" href="cfs__fh_8c.html#a34">buf</a>,totlen)) &lt; 0)
00110                 <span class="keywordflow">return</span> -1;
00111         userbytes=dtov(iolen)-fronterr;
00112         <span class="keywordflow">if</span> (userbytes &lt; 0) <span class="comment">/* empty file */</span>
00113                 <span class="keywordflow">return</span> 0;
00114         dodecrypt(<a class="code" href="mcg_8c.html#a0">key</a>,<a class="code" href="cfs__fh_8c.html#a34">buf</a>,iolen,begin,<a class="code" href="cfs__fh_8c.html#a12">vect</a>);
00115         <span class="comment">/* now copyback to the user's buffer */</span>
00116         bcopy((<span class="keywordtype">char</span> *)(<a class="code" href="cfs__fh_8c.html#a34">buf</a>+fronterr),(<span class="keywordtype">char</span> *)blk,userbytes);
00117         <span class="keywordflow">return</span>(userbytes);
00118 }
00119 
00120 <span class="comment">/*</span>
00121 <span class="comment"> * write an encrypted block to fd</span>
00122 <span class="comment"> */</span>
00123 <span class="keywordtype">int</span>
00124 writeblock(blk,fd,offset,len,key,vect)
00125      <span class="keywordtype">char</span> *blk;     <span class="comment">/* data */</span>
<a name="l00126"></a><a class="code" href="cfs__fh_8c.html#a8">00126</a>      <span class="keywordtype">int</span> <a class="code" href="cfs__fh_8c.html#a8">fd</a>;        <span class="comment">/* fd */</span>
<a name="l00127"></a><a class="code" href="cfs__fh_8c.html#a9">00127</a>      u_long <a class="code" href="cfs__fh_8c.html#a9">offset</a>; <span class="comment">/* offset from byte zero */</span>
<a name="l00128"></a><a class="code" href="cfs__fh_8c.html#a10">00128</a>      u_long <a class="code" href="cfs__fh_8c.html#a0">len</a>;    <span class="comment">/* blk len */</span>
<a name="l00129"></a><a class="code" href="cfs__fh_8c.html#a11">00129</a>      <a class="code" href="structcfskey.html">cfskey</a> *<a class="code" href="mcg_8c.html#a0">key</a>;     <span class="comment">/* des key */</span>
00130      <span class="keywordtype">char</span> *<a class="code" href="cfs__fh_8c.html#a12">vect</a>;    <span class="comment">/* perturb. vector */</span>
00131 {
00132         u_long begin, end;
00133         u_long fronterr, totlen,datalen;
00134         <span class="keywordtype">int</span> iolen;
00135         <span class="keywordtype">int</span> headlen;
00136         <span class="keywordtype">int</span> writemore=0;
00137         <span class="keyword">struct </span>stat <a class="code" href="cfs__fh_8c.html#a25">sb</a>;
00138         u_long mask = ~0;       <span class="comment">/*tells us whether to expand file */</span>
00139         <span class="keywordtype">char</span> <a class="code" href="cfs__fh_8c.html#a34">buf</a>[8216]; <span class="comment">/* big enough, may not even need it */</span>
00140 
00141         <span class="comment">/* first, normalize to the proper boundries */</span>
00142         fronterr = <a class="code" href="cfs__fh_8c.html#a9">offset</a>&amp;(<a class="code" href="cfs_8h.html#a6">CFSBLOCK</a>-1);
00143         datalen=<a class="code" href="cfs__fh_8c.html#a0">len</a>+fronterr;
00144         begin=<a class="code" href="cfs__fh_8c.html#a9">offset</a>-fronterr;
00145         totlen=vtod(datalen);
00146         end=begin+datalen+<a class="code" href="cfs_8h.html#a6">CFSBLOCK</a>; <span class="comment">/* lower bound on end of file */</span>
00147         <span class="keywordflow">if</span> (fstat(<a class="code" href="cfs__fh_8c.html#a8">fd</a>,&amp;<a class="code" href="cfs__fh_8c.html#a25">sb</a>)&lt;0)
00148                 <span class="keywordflow">return</span> -1;      <span class="comment">/* file's not there */</span>
00149         <span class="comment">/* now begin and datalen/totlen are what we do the actual i/o on */</span>
00150         <span class="keywordflow">if</span> (totlen&gt;8208)
00151                 <span class="keywordflow">return</span> -1;      <span class="comment">/* shouldn't happen */</span>
00152         bzero((<span class="keywordtype">char</span> *)<a class="code" href="cfs__fh_8c.html#a34">buf</a>,totlen);
00153         <span class="keywordflow">if</span> ((totlen!=<a class="code" href="cfs__fh_8c.html#a0">len</a>) &amp;&amp; (<a class="code" href="cfs__fh_8c.html#a25">sb</a>.st_size&gt;begin)) {
00154                         <span class="comment">/* read begining and ending slop first */</span>
00155                         <span class="comment">/* we could reduce the size of this read to just</span>
00156 <span class="comment">                           the CFSBLOCKs at the head &amp;/| tail of the file,</span>
00157 <span class="comment">                           but that's probably more trouble than it's worth.*/</span>
00158                 <span class="keywordflow">if</span> (lseek(<a class="code" href="cfs__fh_8c.html#a8">fd</a>,(off_t)begin,L_SET)&lt;0)
00159                         <span class="keywordflow">return</span> -1;
00160                 <span class="comment">/* the extra CFSBLOCK ensures that next block is ok */</span>
00161                 iolen=isbndry(totlen)?totlen:(totlen+<a class="code" href="cfs_8h.html#a6">CFSBLOCK</a>);
00162                 <span class="keywordflow">if</span> ((read(<a class="code" href="cfs__fh_8c.html#a8">fd</a>,<a class="code" href="cfs__fh_8c.html#a34">buf</a>,iolen))&lt;0)
00163                         <span class="keywordflow">return</span> -1;
00164                 dodecrypt(<a class="code" href="mcg_8c.html#a0">key</a>,<a class="code" href="cfs__fh_8c.html#a34">buf</a>,iolen,begin,<a class="code" href="cfs__fh_8c.html#a12">vect</a>);
00165         }
00166 
00167         <span class="comment">/* now we can do the actual encrypt and i/o */</span>
00168         bcopy((<span class="keywordtype">char</span> *)blk,(<span class="keywordtype">char</span> *)(<a class="code" href="cfs__fh_8c.html#a34">buf</a>+fronterr),<a class="code" href="cfs__fh_8c.html#a0">len</a>);
00169         doencrypt(<a class="code" href="mcg_8c.html#a0">key</a>,<a class="code" href="cfs__fh_8c.html#a34">buf</a>,totlen,begin,<a class="code" href="cfs__fh_8c.html#a12">vect</a>);
00170         <span class="keywordflow">if</span> (lseek(<a class="code" href="cfs__fh_8c.html#a8">fd</a>,(off_t)begin,L_SET)&lt;0)
00171                 <span class="keywordflow">return</span> -1;
00172         <span class="comment">/* again, holes in the file are a delicate problem.  If the CFSBLOCK</span>
00173 <span class="comment">           bountry is not always on a file boundry, you could even corrupt</span>
00174 <span class="comment">           valid data.  Fortunately, these both are generally powers of 2,</span>
00175 <span class="comment">           so it's not an issue. */</span>
00176         <span class="keywordflow">if</span> ((iolen=write(<a class="code" href="cfs__fh_8c.html#a8">fd</a>,<a class="code" href="cfs__fh_8c.html#a34">buf</a>,totlen)) &lt; 0) {
00177                 perror(<span class="stringliteral">"write"</span>);
00178                 <span class="keywordflow">return</span> -1;
00179         }
00180         <span class="comment">/* iolen may contain CFSBLOCK extra chars */</span>
00181         <span class="keywordflow">return</span>(dtov(iolen)-fronterr);
00182 }
00183 
00184 
00185 <span class="preprocessor">#define MAXCLEARNAME ((NFS_MAXPATHLEN-7)/2)</span>
00186 <span class="preprocessor"></span>
00187 
00188 <span class="preprocessor">#ifndef USE8BIT</span>
00189 <span class="preprocessor"></span><span class="comment">/*</span>
00190 <span class="comment"> * encrypt a path componenet (no /'s) element</span>
00191 <span class="comment"> *  leave "." and ".." unmolested</span>
00192 <span class="comment"> */</span>
00193 <span class="keywordtype">char</span> *
00194 <a class="code" href="cfs_8h.html#a39">encryptname</a>(key,s)
00195      <a class="code" href="structcfskey.html">cfskey</a> *<a class="code" href="mcg_8c.html#a0">key</a>;
00196      <span class="keywordtype">char</span> *<a class="code" href="cfs__fh_8c.html#a0">s</a>;
00197 {
00198         <span class="keyword">static</span> <span class="keywordtype">char</span> cryptname[NFS_MAXNAMLEN+1];
00199         u_char cryptstring[MAXCLEARNAME+<a class="code" href="cfs_8h.html#a6">CFSBLOCK</a>+1];
00200         u_char x[3];
00201         u_long <a class="code" href="cfs__fh_8c.html#a14">l</a>;
00202         <span class="keywordtype">int</span> i;
00203 
00204         <span class="keywordflow">if</span> ((<a class="code" href="cfs__fh_8c.html#a0">s</a>==NULL) || ((<a class="code" href="cfs__fh_8c.html#a14">l</a>=strlen(s)+1)&gt;MAXCLEARNAME))
00205                 <span class="keywordflow">return</span> NULL;
00206         <span class="keywordflow">if</span> (!strcmp(s,<span class="stringliteral">"."</span>) || !strcmp(s,<span class="stringliteral">".."</span>))
00207                 <span class="keywordflow">return</span> <a class="code" href="cfs__fh_8c.html#a0">s</a>;
00208         <a class="code" href="cfs__fh_8c.html#a14">l</a>=(<a class="code" href="cfs__fh_8c.html#a14">l</a>+(<a class="code" href="cfs_8h.html#a6">CFSBLOCK</a>-1)) &amp; (~(<a class="code" href="cfs_8h.html#a6">CFSBLOCK</a>-1));
00209         bzero((<span class="keywordtype">char</span> *)cryptstring,l);
00210         strcpy(cryptstring,s);
00211         chksum(cryptstring,l);
00212         doencrypt(key,cryptstring,l,10241,zerovect);
00213         cryptname[0]=<span class="charliteral">'\0'</span>;
00214         <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="cfs__fh_8c.html#a14">l</a>; i++) {
00215                 sprintf((<span class="keywordtype">char</span> *)x,<span class="stringliteral">"%02x"</span>,cryptstring[i]);
00216                 strcat(cryptname,x);
00217         }
00218         <span class="keywordflow">return</span> cryptname;
00219 }
00220 <span class="preprocessor">#else</span>
00221 <span class="preprocessor"></span><span class="comment">/*</span>
00222 <span class="comment"> * encrypt a path componenet (no /'s) element</span>
00223 <span class="comment"> *  leave "." and ".." unmolested</span>
00224 <span class="comment"> *</span>
00225 <span class="comment"> * XXX - JR - XXX</span>
00226 <span class="comment"> *      Not true. When decrypting a symlink pointer, decryptname</span>
00227 <span class="comment"> *      is called with the full path encoded by the link,</span>
00228 <span class="comment"> *      which, of course, may contain '/' elements.</span>
00229 <span class="comment"> *      I say so because I tried first encrypting/decrypting</span>
00230 <span class="comment"> *      8bit chars by scaping them with a '/', however this</span>
00231 <span class="comment"> *      broke symlinks.</span>
00232 <span class="comment"> *      That's why I now use another one. Sensible ones may be</span>
00233 <span class="comment"> *              SUB (\032   26    0x1A)         ASCII Substitute</span>
00234 <span class="comment"> *              ESC (\033   27    0x1B)         ASCII Escape</span>
00235 <span class="comment"> */</span>
00236 <span class="comment">/* define ESCAPE_CHAR '/' */</span>
00237 <span class="comment">/* define ESCAPE_CHAR '0x1A' */</span>
00238 <span class="preprocessor">#define ESCAPE_CHAR 0x1B</span>
00239 <span class="preprocessor"></span>
00240 <span class="keywordtype">char</span> *
00241 <a class="code" href="cfs_8h.html#a39">encryptname</a>(key,s)
00242      <a class="code" href="structcfskey.html">cfskey</a> *<a class="code" href="mcg_8c.html#a0">key</a>;
00243      <span class="keywordtype">char</span> *<a class="code" href="cfs__fh_8c.html#a0">s</a>;
00244 {
00245         <span class="keyword">static</span> <span class="keywordtype">char</span> cryptname[NFS_MAXNAMLEN+1];
00246         u_char cryptstring[MAXCLEARNAME+<a class="code" href="cfs_8h.html#a6">CFSBLOCK</a>+1];
00247         u_char x[3];
00248         u_long <a class="code" href="cfs__fh_8c.html#a14">l</a>;
00249         <span class="keywordtype">int</span> i, j;
00250 
00251         <span class="comment">/* XXX - JR - XXX </span>
00252 <span class="comment">         * To provide for 8-bit clean filenames, we need to hack actual</span>
00253 <span class="comment">         * names. Reason:</span>
00254 <span class="comment">         *      chksum() modifies the MSB of chars in the string</span>
00255 <span class="comment">         *      using a checksum algorithm. This is not easily undoable,</span>
00256 <span class="comment">         *      at least not in the absence of proper documentation.</span>
00257 <span class="comment">         *      The decryptname function will just CLEAR the MSB of</span>
00258 <span class="comment">         *      EVERY character in the end, removing 8-bit details.</span>
00259 <span class="comment">         *</span>
00260 <span class="comment">         * Not having details on why this is done, and lacking time to</span>
00261 <span class="comment">         * get into more detailed study, a Q&amp;D hack is to encode the names</span>
00262 <span class="comment">         * prior to processing.</span>
00263 <span class="comment">         *</span>
00264 <span class="comment">         *      Rule:</span>
00265 <span class="comment">         *      If a char is 8-bit then recode as 'ESCAPE_CHAR',char&amp;0x7f</span>
00266 <span class="comment">         *      If new-string-length exceeds MAXCLEARNAME, return NULL</span>
00267 <span class="comment">         *      Otherwise procceed.</span>
00268 <span class="comment">         *</span>
00269 <span class="comment">         *      Converse processing is needed in decryptname</span>
00270 <span class="comment">         *      if an 'ESCAPE_CHAR' is found, remove it and use char|0x7f</span>
00271 <span class="comment">         *</span>
00272 <span class="comment">         *      We use '/' for ESCAPE_CHAR can not be a part of a filename</span>
00273 <span class="comment">         *      and we get stripped filenames here. NOTE: no longer, it</span>
00274 <span class="comment">         *      breaks symlinks.</span>
00275 <span class="comment">         *      We can't scape ESCAPE_CHAR itself for then we wouldn't be</span>
00276 <span class="comment">         *      able to recode the (ESCAPE_CHAR | 0x80) character.</span>
00277 <span class="comment">         */</span>
00278         u_char s8[MAXCLEARNAME+1];
00279         
00280         <span class="keywordflow">if</span> ((<a class="code" href="cfs__fh_8c.html#a0">s</a>==NULL) || ((<a class="code" href="cfs__fh_8c.html#a14">l</a>=strlen(s)+1)&gt;MAXCLEARNAME))
00281                 <span class="keywordflow">return</span> NULL;
00282         <span class="keywordflow">if</span> (!strcmp(s,<span class="stringliteral">"."</span>) || !strcmp(s,<span class="stringliteral">".."</span>))
00283                 <span class="keywordflow">return</span> <a class="code" href="cfs__fh_8c.html#a0">s</a>;
00284 
00285         <span class="comment">/* do the recoding */</span>
00286         i = j = 0;
00287         <span class="keywordflow">while</span> (<a class="code" href="cfs__fh_8c.html#a0">s</a>[i] != <span class="charliteral">'\0'</span>) {
00288             <span class="keywordflow">if</span> (j &gt; MAXCLEARNAME) <span class="keywordflow">return</span> NULL;
00289             <span class="keywordflow">if</span> (<a class="code" href="cfs__fh_8c.html#a0">s</a>[i] &amp; 0x80) {
00290                 s8[j] = ESCAPE_CHAR; j++;
00291                 s8[j] = <a class="code" href="cfs__fh_8c.html#a0">s</a>[i] &amp; 0x7f;
00292                 i++, j++;
00293             }
00294             <span class="keywordflow">else</span> {
00295                 s8[j] = <a class="code" href="cfs__fh_8c.html#a0">s</a>[i];
00296                 i++; j++;
00297             }
00298         }
00299         s8[j] = <span class="charliteral">'\0'</span>;
00300         <a class="code" href="cfs__fh_8c.html#a14">l</a>=strlen(s8) +1;
00301         
00302         <a class="code" href="cfs__fh_8c.html#a14">l</a>=(<a class="code" href="cfs__fh_8c.html#a14">l</a>+(<a class="code" href="cfs_8h.html#a6">CFSBLOCK</a>-1)) &amp; (~(<a class="code" href="cfs_8h.html#a6">CFSBLOCK</a>-1));
00303         bzero((<span class="keywordtype">char</span> *)cryptstring,l);
00304         strcpy(cryptstring,s8);
00305         chksum(cryptstring,l);
00306         doencrypt(key,cryptstring,l,10241,zerovect);
00307         cryptname[0]=<span class="charliteral">'\0'</span>;
00308         <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="cfs__fh_8c.html#a14">l</a>; i++) {
00309                 sprintf((<span class="keywordtype">char</span> *)x,<span class="stringliteral">"%02x"</span>,cryptstring[i]);
00310                 strcat(cryptname,x);
00311         }
00312         <span class="keywordflow">return</span> cryptname;
00313 }
00314 <span class="preprocessor">#endif</span>
00315 <span class="preprocessor"></span>
00316 <span class="comment">/*</span>
00317 <span class="comment"> * set high order bits</span>
00318 <span class="comment"> */</span>
00319 chksum(s,l)
00320      <span class="keywordtype">char</span> *<a class="code" href="cfs__fh_8c.html#a0">s</a>;
00321      <span class="keywordtype">long</span> <a class="code" href="cfs__fh_8c.html#a14">l</a>;
00322 {
00323         u_long acc;
00324         <span class="keywordtype">int</span> i;
00325         u_char <a class="code" href="esm__cipher_8c.html#a27">bits</a>[8];
00326 
00327         acc=0;
00328         <span class="keywordflow">for</span> (i=0; <a class="code" href="cfs__fh_8c.html#a0">s</a>[i]!=<span class="charliteral">'\0'</span>; i++)
00329                 acc += <a class="code" href="cfs__fh_8c.html#a0">s</a>[i]*((i%6)+1);
00330         <span class="keywordflow">for</span> (i++; i&lt;<a class="code" href="cfs__fh_8c.html#a14">l</a>; i++)     <span class="comment">/* fill up the end */</span>
00331                 <a class="code" href="cfs__fh_8c.html#a0">s</a>[i] = <a class="code" href="cfs__fh_8c.html#a0">s</a>[i%8];
00332         <span class="keywordflow">for</span> (i=0; i&lt;8; i++)
00333                 <a class="code" href="esm__cipher_8c.html#a27">bits</a>[i] = (acc&lt;&lt;(i%8))&amp;0x80;
00334         <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="cfs__fh_8c.html#a14">l</a>; i++)
00335                 <a class="code" href="cfs__fh_8c.html#a0">s</a>[i] |= <a class="code" href="esm__cipher_8c.html#a27">bits</a>[i%8];
00336 }
00337 
00338 <span class="preprocessor">#ifndef USE8BIT</span>
00339 <span class="preprocessor"></span><span class="comment">/*</span>
00340 <span class="comment"> * decrypt path component</span>
00341 <span class="comment"> *  leaving "." and ".."</span>
00342 <span class="comment"> */</span>
00343 <span class="keywordtype">char</span> *
00344 <a class="code" href="cfs_8h.html#a40">decryptname</a>(key,s)
00345      <a class="code" href="structcfskey.html">cfskey</a> *<a class="code" href="mcg_8c.html#a0">key</a>;
00346      <span class="keywordtype">char</span> *<a class="code" href="cfs__fh_8c.html#a0">s</a>;
00347 {
00348         <span class="keyword">static</span> <span class="keywordtype">char</span> clearstring[MAXCLEARNAME+<a class="code" href="cfs_8h.html#a6">CFSBLOCK</a>+1];
00349         <span class="keywordtype">char</span> x[3];
00350         <span class="keywordtype">int</span> y;
00351         <span class="keywordtype">char</span> *p, *q;
00352         <span class="keywordtype">int</span> <a class="code" href="cfs__fh_8c.html#a14">l</a>;
00353         <span class="keywordtype">int</span> i;
00354 
00355         <span class="keywordflow">if</span> (<a class="code" href="cfs__fh_8c.html#a0">s</a>==NULL)
00356                 <span class="keywordflow">return</span> NULL;
00357         <span class="keywordflow">if</span> (!strcmp(s,<span class="stringliteral">"."</span>) || !strcmp(s,<span class="stringliteral">".."</span>))
00358                 <span class="keywordflow">return</span> <a class="code" href="cfs__fh_8c.html#a0">s</a>;
00359         bzero((<span class="keywordtype">char</span> *)clearstring,MAXCLEARNAME+CFSBLOCK+1);
00360         <span class="comment">/* unencode the string */</span>
00361         p=<a class="code" href="cfs__fh_8c.html#a0">s</a>;
00362         q=clearstring;
00363         x[2]=<span class="charliteral">'\0'</span>;
00364         <a class="code" href="cfs__fh_8c.html#a14">l</a>=0;
00365         <span class="keywordflow">while</span> (*p) {
00366                 x[0] = *p++;
00367                 <span class="keywordflow">if</span> ((x[1] = *p++) == <span class="charliteral">'\0'</span>)
00368                         <span class="keywordflow">return</span> NULL;
00369                 <span class="keywordflow">if</span> (sscanf(x,<span class="stringliteral">"%x"</span>,&amp;y)!=1)
00370                         <span class="keywordflow">return</span> NULL;
00371                 *q++ = y;
00372                 <a class="code" href="cfs__fh_8c.html#a14">l</a>++;
00373         }
00374         *q=<span class="charliteral">'\0'</span>;        <span class="comment">/* shouldnt need this */</span>
00375         <span class="keywordflow">if</span> (<a class="code" href="cfs__fh_8c.html#a14">l</a>%<a class="code" href="cfs_8h.html#a6">CFSBLOCK</a>)
00376                 <span class="keywordflow">return</span> NULL;
00377         dodecrypt(key,clearstring,l,10241,zerovect);
00378         <span class="keywordflow">for</span> (i=0; (clearstring[i]&amp;0x7f) !=<span class="charliteral">'\0'</span>; i++)
00379                 clearstring[i] &amp;= 0x7f;
00380         clearstring[i]=<span class="charliteral">'\0'</span>;
00381         <span class="keywordflow">return</span> clearstring;
00382 }
00383 <span class="preprocessor">#else</span>
00384 <span class="preprocessor"></span><span class="comment">/*</span>
00385 <span class="comment"> * decrypt path component</span>
00386 <span class="comment"> *  leaving "." and ".."</span>
00387 <span class="comment"> */</span>
00388 <span class="keywordtype">char</span> *
00389 <a class="code" href="cfs_8h.html#a40">decryptname</a>(key,s)
00390      <a class="code" href="structcfskey.html">cfskey</a> *<a class="code" href="mcg_8c.html#a0">key</a>;
00391      <span class="keywordtype">char</span> *<a class="code" href="cfs__fh_8c.html#a0">s</a>;
00392 {
00393         <span class="keyword">static</span> <span class="keywordtype">char</span> clearstring[MAXCLEARNAME+<a class="code" href="cfs_8h.html#a6">CFSBLOCK</a>+1];
00394         <span class="keywordtype">char</span> x[3];
00395         <span class="keywordtype">int</span> y;
00396         <span class="keywordtype">char</span> *p, *q;
00397         <span class="keywordtype">int</span> <a class="code" href="cfs__fh_8c.html#a14">l</a>;
00398         <span class="keywordtype">int</span> i, j;
00399 
00400         <span class="keywordflow">if</span> (<a class="code" href="cfs__fh_8c.html#a0">s</a>==NULL)
00401                 <span class="keywordflow">return</span> NULL;
00402         <span class="keywordflow">if</span> (!strcmp(s,<span class="stringliteral">"."</span>) || !strcmp(s,<span class="stringliteral">".."</span>))
00403                 <span class="keywordflow">return</span> <a class="code" href="cfs__fh_8c.html#a0">s</a>;
00404         bzero((<span class="keywordtype">char</span> *)clearstring,MAXCLEARNAME+CFSBLOCK+1);
00405         <span class="comment">/* unencode the string */</span>
00406         p=<a class="code" href="cfs__fh_8c.html#a0">s</a>;
00407         q=clearstring;
00408         x[2]=<span class="charliteral">'\0'</span>;
00409         <a class="code" href="cfs__fh_8c.html#a14">l</a>=0;
00410         <span class="keywordflow">while</span> (*p) {
00411                 x[0] = *p++;
00412                 <span class="keywordflow">if</span> ((x[1] = *p++) == <span class="charliteral">'\0'</span>)
00413                         <span class="keywordflow">return</span> NULL;
00414                 <span class="keywordflow">if</span> (sscanf(x,<span class="stringliteral">"%x"</span>,&amp;y)!=1)
00415                         <span class="keywordflow">return</span> NULL;
00416                 *q++ = y;
00417                 <a class="code" href="cfs__fh_8c.html#a14">l</a>++;
00418         }
00419         *q=<span class="charliteral">'\0'</span>;        <span class="comment">/* shouldnt need this */</span>
00420         <span class="keywordflow">if</span> (<a class="code" href="cfs__fh_8c.html#a14">l</a>%<a class="code" href="cfs_8h.html#a6">CFSBLOCK</a>)
00421                 <span class="keywordflow">return</span> NULL;
00422         dodecrypt(key,clearstring,l,10241,zerovect);
00423         <span class="keywordflow">for</span> (i=0; (clearstring[i]&amp;0x7f) !=<span class="charliteral">'\0'</span>; i++)
00424                 clearstring[i] &amp;= 0x7f;
00425         clearstring[i]=<span class="charliteral">'\0'</span>;
00426         
00427         <span class="comment">/* XXX - JR - XXX</span>
00428 <span class="comment">         * To recover the 8bit clear filename we still need one</span>
00429 <span class="comment">         * more step:</span>
00430 <span class="comment">         *      Locate all 'ESCAPE_CHAR' characters, remove them and add </span>
00431 <span class="comment">         * the 8th bit to the character following.</span>
00432 <span class="comment">         *      This may be done in place.</span>
00433 <span class="comment">         */</span>
00434         <span class="keywordflow">for</span> (i = j = 0; clearstring[i] != <span class="charliteral">'\0'</span>; i++, j++) {
00435             <span class="keywordflow">if</span> (clearstring[i] == ESCAPE_CHAR) {
00436                 i++;
00437                 clearstring[j] = clearstring[i] | 0x80;
00438             
00439            } <span class="keywordflow">else</span>
00440                 clearstring[j] = clearstring[i];
00441         }
00442         clearstring[j] = <span class="charliteral">'\0'</span>;
00443         
00444         <span class="keywordflow">return</span> clearstring;
00445 }
00446 <span class="preprocessor">#endif</span>
00447 <span class="preprocessor"></span>
00448 doencrypt(k,s,l,salt,vect)
00449      <a class="code" href="structcfskey.html">cfskey</a> *<a class="code" href="getpass_8c.html#a3">k</a>;         <span class="comment">/* key to use */</span>
00450      <span class="keywordtype">char</span> *<a class="code" href="cfs__fh_8c.html#a0">s</a>;           <span class="comment">/* string to encrypt */</span>
00451      <span class="keywordtype">int</span> <a class="code" href="cfs__fh_8c.html#a14">l</a>;             <span class="comment">/* strlen */</span>
00452      <span class="keywordtype">int</span> <a class="code" href="cfs__fh_8c.html#a15">salt</a>;
00453      <span class="keywordtype">char</span> *<a class="code" href="cfs__fh_8c.html#a12">vect</a>;
00454 {
00455         <span class="keywordtype">int</span> i,j,smsize;
00456         
00457         smsize=<a class="code" href="getpass_8c.html#a3">k</a>-&gt;smsize;
00458         <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="cfs__fh_8c.html#a14">l</a>; i+=8) {
00459                 <span class="keywordflow">for</span> (j=0; j&lt;8; j++)
00460                         <a class="code" href="cfs__fh_8c.html#a0">s</a>[i+j] ^= <a class="code" href="getpass_8c.html#a3">k</a>-&gt;primask[(i+j+<a class="code" href="cfs__fh_8c.html#a15">salt</a>)%smsize]
00461                                 ^ <a class="code" href="cfs__fh_8c.html#a12">vect</a>[j]
00462                                 ^ (((i+j+<a class="code" href="cfs__fh_8c.html#a15">salt</a>)/smsize)&amp;0377);
00463                                 <span class="comment">/* makes big offsets have different masks */</span>
00464                 <a class="code" href="cfs__cipher_8c.html#a3">cipher</a>(k,&amp;s[i],0);
00465                 <span class="keywordflow">for</span> (j=0; j&lt;8; j++)
00466                         <a class="code" href="cfs__fh_8c.html#a0">s</a>[i+j] ^= <a class="code" href="getpass_8c.html#a3">k</a>-&gt;secmask[(i+j+<a class="code" href="cfs__fh_8c.html#a15">salt</a>)%smsize];
00467         }
00468 }
00469 
00470 dodecrypt(k,s,l,salt,vect)
00471      <a class="code" href="structcfskey.html">cfskey</a> *<a class="code" href="getpass_8c.html#a3">k</a>;
00472      <span class="keywordtype">char</span> *<a class="code" href="cfs__fh_8c.html#a0">s</a>;
<a name="l00473"></a><a class="code" href="cfs__fh_8c.html#a14">00473</a>      <span class="keywordtype">int</span> <a class="code" href="cfs__fh_8c.html#a14">l</a>;
<a name="l00474"></a><a class="code" href="cfs__fh_8c.html#a15">00474</a>      <span class="keywordtype">int</span> <a class="code" href="cfs__fh_8c.html#a15">salt</a>;
00475      <span class="keywordtype">char</span> *<a class="code" href="cfs__fh_8c.html#a12">vect</a>;
00476 {
00477         <span class="keywordtype">int</span> i,j,smsize;
00478         
00479         smsize=<a class="code" href="getpass_8c.html#a3">k</a>-&gt;smsize;
00480         <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="cfs__fh_8c.html#a14">l</a>; i+=8) {
00481                 <span class="keywordflow">for</span> (j=0; j&lt;8; j++)
00482                         <a class="code" href="cfs__fh_8c.html#a0">s</a>[i+j] ^= <a class="code" href="getpass_8c.html#a3">k</a>-&gt;secmask[(i+j+<a class="code" href="cfs__fh_8c.html#a15">salt</a>)%smsize];
00483                 <a class="code" href="cfs__cipher_8c.html#a3">cipher</a>(<a class="code" href="getpass_8c.html#a3">k</a>,&amp;<a class="code" href="cfs__fh_8c.html#a0">s</a>[i],1);
00484                 <span class="keywordflow">for</span> (j=0; j&lt;8; j++)
00485                         <a class="code" href="cfs__fh_8c.html#a0">s</a>[i+j] ^= <a class="code" href="getpass_8c.html#a3">k</a>-&gt;primask[(i+j+<a class="code" href="cfs__fh_8c.html#a15">salt</a>)%smsize]
00486                                 ^ <a class="code" href="cfs__fh_8c.html#a12">vect</a>[j]
00487                                 ^ (((i+j+<a class="code" href="cfs__fh_8c.html#a15">salt</a>)/smsize) &amp; 0377);
00488         }
00489                 
00490 }
00491 
00492 <span class="comment">/*</span>
00493 <span class="comment"> * convert size of data to size of block to be written</span>
00494 <span class="comment"> */</span>
00495 vtod(d)
00496      <span class="keywordtype">int</span> <a class="code" href="cfs__cipher_8c.html#a1">d</a>;
00497 {
00498         <span class="keywordflow">return</span> isbndry(d)?<a class="code" href="cfs__cipher_8c.html#a1">d</a>:(<a class="code" href="cfs__cipher_8c.html#a1">d</a>+<a class="code" href="cfs_8h.html#a6">CFSBLOCK</a>);
00499 }
00500 
00501 
00502 <span class="comment">/*</span>
00503 <span class="comment"> * convert file size into #of valid bits</span>
00504 <span class="comment"> */</span>
00505 dtov(d)
00506      <span class="keywordtype">int</span> <a class="code" href="cfs__cipher_8c.html#a1">d</a>;
00507 {
00508         <span class="keywordflow">return</span> isbndry(d)?<a class="code" href="cfs__cipher_8c.html#a1">d</a>:(<a class="code" href="cfs__cipher_8c.html#a1">d</a>-<a class="code" href="cfs_8h.html#a6">CFSBLOCK</a>);
00509 }
00510 
00511 <span class="comment">/*</span>
00512 <span class="comment"> * is block size a CFS boundry?</span>
00513 <span class="comment"> */</span>
00514 isbndry(d)
00515      <span class="keywordtype">int</span> <a class="code" href="cfs__cipher_8c.html#a1">d</a>;
00516 {
00517         <span class="keywordflow">return</span> ((<a class="code" href="cfs__cipher_8c.html#a1">d</a>&amp;(<a class="code" href="cfs_8h.html#a6">CFSBLOCK</a>-1))==0);
00518 }
00519 
00520 
00521 <span class="keyword">static</span> <a class="code" href="unionfh__u.html">fh_u</a> roothandle;
<a name="l00522"></a><a class="code" href="cfs__fh_8c.html#a16">00522</a> <a class="code" href="structcfs__fileid.html">cfs_fileid</a> <a class="code" href="cfs_8h.html#a37">rootnode</a>={1,0,<span class="stringliteral">"\0\0\0\0\0\0\0\0"</span>,<span class="stringliteral">"/NOWHERE/null"</span>,NULL,NULL,0,NULL,NULL};<span class="comment">/* fileid=1; should be unique */</span>
<a name="l00523"></a><a class="code" href="cfs__fh_8c.html#a17">00523</a> nfstime <a class="code" href="cfs_8h.html#a36">roottime</a>={0,0};
00524 
00525 <span class="comment">/* Had to change this - someone else was using the same magic number! */</span>
00526 <span class="comment">/* PLEASE change this value if you're going to re-use this code for</span>
00527 <span class="comment">/* something else!  Otherwise your FS and CFS can't both run... */</span>
00528 <span class="comment">/* static u_char magictest[8]={0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef}; */</span>
00529 <span class="keyword">static</span> u_char magictest[8]=<span class="stringliteral">"M.Blaze"</span>;
00530 
00531 <span class="keyword">static</span> <a class="code" href="structcfs__fileid.html">cfs_fileid</a> *
00532 findh(id,ins
00533 #ifdef SHORTLINKS
00534             ,linkid)
00535      <span class="keywordtype">int</span> linkid;
00536 <span class="preprocessor">#else </span><span class="comment">/* SHORTLINKS */</span>
00537      )
00538 <span class="preprocessor">#endif </span><span class="comment">/* SHORTLINKS */</span>
00539      <span class="keywordtype">int</span> id;
<a name="l00540"></a><a class="code" href="cfs__fh_8c.html#a19">00540</a>      <span class="keywordtype">int</span> <a class="code" href="cfs__fh_8c.html#a19">ins</a>;
00541 {
00542         u_int bucket;
00543         <a class="code" href="structcfs__fileid.html">cfs_fileid</a> *f;
00544         
00545         bucket=<a class="code" href="cfs__fh_8c.html#a0">hash</a>(id);
00546         f=<a class="code" href="cfs_8h.html#a35">instances</a>[<a class="code" href="cfs__fh_8c.html#a19">ins</a>]-&gt;file[bucket];
00547         <span class="keywordflow">while</span> (f!=NULL) {
00548                 <span class="keywordflow">if</span> (f-&gt;<a class="code" href="structcfs__fileid.html#o0">fileid</a> == id)    <span class="comment">/* note recast */</span>
00549 <span class="preprocessor">#ifdef SHORTLINKS</span>
00550 <span class="preprocessor"></span>                    <span class="keywordflow">if</span> (f-&gt;linkid == linkid)
00551 <span class="preprocessor">#endif </span><span class="comment">/* SHORTLINKS */</span>
00552                         <span class="keywordflow">return</span> f;
00553                 f=f-&gt;<a class="code" href="structcfs__fileid.html#o7">next</a>;
00554         }
00555         <span class="keywordflow">return</span> NULL;
00556 }
00557 
00558 
00559 <a class="code" href="structcfs__fileid.html">cfs_fileid</a> *
00560 <a class="code" href="cfs_8h.html#a41">geth</a>(h)
00561      <a class="code" href="structfhdata.html">fhdata</a> *<a class="code" href="cfs__fh_8c.html#a28">h</a>; <span class="comment">/* note recasting here - may give trouble with strict ansi */</span>
00562 {
00563         <span class="keywordtype">int</span> i;
00564         <a class="code" href="structcfs__fileid.html">cfs_fileid</a> *r;
00565 
00566         <span class="keywordflow">if</span> (<a class="code" href="cfs__fh_8c.html#a28">h</a>==NULL)
00567                 <span class="keywordflow">return</span> &amp;<a class="code" href="cfs_8h.html#a37">rootnode</a>;
00568         <span class="comment">/* check for rootness */</span>
00569         <span class="keywordflow">for</span> (i=0; i&lt;8; i++)
00570                 <span class="keywordflow">if</span> (<a class="code" href="cfs__fh_8c.html#a28">h</a>-&gt;<a class="code" href="structfhdata.html#o0">magic</a>[i] != magictest[i]) {
00571                         <span class="comment">/* update the root handle, so we return the</span>
00572 <span class="comment">                           latest thing it gave out for lookups of /.  */</span>
00573                         bcopy((<span class="keywordtype">char</span> *)h,(<span class="keywordtype">char</span>*)&amp;roothandle,<span class="keyword">sizeof</span>(roothandle));
00574                         <span class="keywordflow">return</span> &amp;<a class="code" href="cfs_8h.html#a37">rootnode</a>;
00575                 }
00576         <span class="keywordflow">if</span> (<a class="code" href="cfs_8h.html#a35">instances</a>[<a class="code" href="cfs__fh_8c.html#a28">h</a>-&gt;<a class="code" href="structfhdata.html#o2">instance</a>] == NULL)
00577                 <span class="keywordflow">return</span> NULL;    <span class="comment">/* invalid/stale instance */</span>
00578         r=findh(<a class="code" href="cfs__fh_8c.html#a28">h</a>-&gt;<a class="code" href="structfhdata.html#o3">fileid</a>,<a class="code" href="cfs__fh_8c.html#a28">h</a>-&gt;<a class="code" href="structfhdata.html#o2">instance</a>
00579 #ifdef SHORTLINKS
00580                                      ,<a class="code" href="cfs__fh_8c.html#a28">h</a>-&gt;linkid
00581 #endif <span class="comment">/* SHORTLINKS */</span>
00582                                      );
00583         <span class="comment">/* instance may have timed out */</span>
00584         <span class="keywordflow">if</span> ((r != NULL) &amp;&amp; (r-&gt;<a class="code" href="structcfs__fileid.html#o8">ins</a>-&gt;<a class="code" href="structinstance.html#o12">dead</a> != 0)) {
00585                 <span class="comment">/* if so, we GC it first */</span>
00586                 freeinstance(<a class="code" href="cfs__fh_8c.html#a28">h</a>-&gt;<a class="code" href="structfhdata.html#o2">instance</a>);
00587                 r=NULL;
00588         }
00589         <span class="keywordflow">if</span> ((r==NULL) || (bcmp(r-&gt;<a class="code" href="structcfs__fileid.html#o8">ins</a>-&gt;<a class="code" href="structinstance.html#o4">check</a>,<a class="code" href="cfs__fh_8c.html#a28">h</a>-&gt;<a class="code" href="structfhdata.html#o4">check</a>,8)!=0))
00590                 <span class="keywordflow">return</span> NULL;    <span class="comment">/* cheater */</span>
00591         <span class="keywordflow">return</span> r;
00592 }
00593 
00594 
00595 htype(f)
00596      <a class="code" href="structcfs__fileid.html">cfs_fileid</a> *f;
00597 {
00598         <span class="keywordflow">if</span> (f == &amp;<a class="code" href="cfs_8h.html#a37">rootnode</a>)
00599                 <span class="keywordflow">return</span> <a class="code" href="cfs_8h.html#a2">H_ROOT</a>;
00600         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (f == NULL)
00601                 <span class="keywordflow">return</span> <a class="code" href="cfs_8h.html#a3">H_INVALID</a>;
00602         <span class="keywordflow">else</span>
00603                 <span class="keywordflow">return</span> <a class="code" href="cfs_8h.html#a0">H_REG</a>;
00604 }
00605 
00606 <a class="code" href="cfs__fh_8c.html#a32">iid</a>(f)
00607      <a class="code" href="structcfs__fileid.html">cfs_fileid</a> *f;
00608 {
00609         <span class="keywordflow">if</span> (f == &amp;<a class="code" href="cfs_8h.html#a37">rootnode</a>)
00610                 <span class="keywordflow">return</span> -1;
00611         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (f == NULL)
00612                 <span class="keywordflow">return</span> -2;
00613         <span class="keywordflow">else</span>
00614                 <span class="keywordflow">return</span> f-&gt;<a class="code" href="structcfs__fileid.html#o8">ins</a>-&gt;<a class="code" href="structinstance.html#o6">id</a>;
00615 }
00616 
00617 fhowner(f,uid)
00618      <a class="code" href="structcfs__fileid.html">cfs_fileid</a> *f;
<a name="l00619"></a><a class="code" href="cfs__fh_8c.html#a20">00619</a>      <span class="keywordtype">int</span> <a class="code" href="cfs__fh_8c.html#a20">uid</a>;
00620 {
00621         <span class="keywordflow">if</span> (f-&gt;<a class="code" href="structcfs__fileid.html#o0">fileid</a> == 0)     <span class="comment">/* an instance root */</span>
00622                 <span class="keywordflow">return</span> (f-&gt;<a class="code" href="structcfs__fileid.html#o8">ins</a>-&gt;<a class="code" href="structinstance.html#o5">uid</a>);   <span class="comment">/* return the instance owner */</span>
00623         <span class="keywordflow">return</span> (<a class="code" href="cfs__fh_8c.html#a20">uid</a>);   <span class="comment">/* normal case */</span>
00624 }
00625 
00626 fhmode(f,mode)
00627      <a class="code" href="structcfs__fileid.html">cfs_fileid</a> *f;
00628      <span class="keywordtype">int</span> <a class="code" href="cfs__fh_8c.html#a21">mode</a>;
00629 {
00630         <span class="keywordflow">if</span> (f-&gt;<a class="code" href="structcfs__fileid.html#o0">fileid</a> == 0)     <span class="comment">/* an instance root */</span>
00631                 <span class="keywordflow">return</span> (<a class="code" href="cfs__fh_8c.html#a21">mode</a>&amp;(~077));   <span class="comment">/* set a umask of 0077 */</span>
00632         <span class="keywordflow">return</span> (<a class="code" href="cfs__fh_8c.html#a21">mode</a>);
00633 }
00634 
00635 <span class="comment">/* return the inode of me */</span>
00636 fhid(f)
00637      <a class="code" href="structcfs__fileid.html">cfs_fileid</a> *f;
00638 {
00639         <span class="keywordflow">if</span> (f==NULL)
00640                 <span class="keywordflow">return</span> 1;
00641         <span class="keywordflow">if</span> (f-&gt;<a class="code" href="structcfs__fileid.html#o0">fileid</a> == 0)     <span class="comment">/* an instance root */</span>
00642                 <span class="keywordflow">return</span> (0-f-&gt;<a class="code" href="structcfs__fileid.html#o8">ins</a>-&gt;<a class="code" href="structinstance.html#o6">id</a>);  <span class="comment">/* should be unique enough */</span>
00643         <span class="keywordflow">return</span> (f-&gt;<a class="code" href="structcfs__fileid.html#o0">fileid</a>);
00644 }
00645 
00646 <span class="comment">/* return the inode of .. (directory only) */</span>
00647 fhpid(f)
00648      <a class="code" href="structcfs__fileid.html">cfs_fileid</a> *f;
00649 {
00650         <span class="keywordflow">if</span> (f==NULL)    <span class="comment">/* this is main root */</span>
00651                 <span class="keywordflow">return</span> 1;
00652         <span class="keywordflow">if</span> (f-&gt;<a class="code" href="structcfs__fileid.html#o6">parent</a>&lt;=0) <span class="comment">/* child of instance root */</span>
00653                 <span class="keywordflow">if</span> (f-&gt;<a class="code" href="structcfs__fileid.html#o0">fileid</a>==0)
00654                         <span class="keywordflow">return</span> 1;
00655                 <span class="keywordflow">else</span>
00656                         <span class="keywordflow">return</span> (0-f-&gt;<a class="code" href="structcfs__fileid.html#o8">ins</a>-&gt;<a class="code" href="structinstance.html#o6">id</a>);
00657         <span class="keywordflow">return</span> f-&gt;<a class="code" href="structcfs__fileid.html#o6">parent</a>;       <span class="comment">/* this is already 2 for main root  */</span>
00658 }
00659 
00660 <span class="comment">/* is uid authorized for this? */</span>
00661 fhuid(f,u)
00662      <a class="code" href="structcfs__fileid.html">cfs_fileid</a> *f;
<a name="l00663"></a><a class="code" href="cfs__fh_8c.html#a22">00663</a>      <span class="keywordtype">int</span> <a class="code" href="cfs__fh_8c.html#a22">u</a>;
00664 {
00665         <span class="keywordflow">if</span> (f==NULL)
00666                 <span class="keywordflow">return</span> 1;
00667         <span class="keywordflow">if</span> (f-&gt;<a class="code" href="structcfs__fileid.html#o0">fileid</a> == 1)     <span class="comment">/* special case */</span>
00668                 <span class="keywordflow">return</span> 1;
00669         <span class="keywordflow">if</span> (f-&gt;<a class="code" href="structcfs__fileid.html#o8">ins</a>-&gt;<a class="code" href="structinstance.html#o10">idle</a> &amp;&amp; f-&gt;<a class="code" href="structcfs__fileid.html#o0">fileid</a>) <span class="comment">/* update idle timer */</span>
00670                 f-&gt;<a class="code" href="structcfs__fileid.html#o8">ins</a>-&gt;<a class="code" href="structinstance.html#o11">access</a>=<a class="code" href="ccat_8c.html#a2">cursecs</a>;
00671         <span class="keywordflow">return</span> (f-&gt;<a class="code" href="structcfs__fileid.html#o8">ins</a>-&gt;<a class="code" href="structinstance.html#o5">uid</a>==<a class="code" href="cfs__fh_8c.html#a22">u</a>);
00672 }
00673 
00674 cfsno(err)
00675      <span class="keywordtype">int</span> err;
00676 {
00677 <span class="comment">/*      if (err==ENOENT)</span>
00678 <span class="comment">                return NFSERR_STALE;</span>
00679 <span class="comment">        else */</span>
00680                 <span class="keywordflow">return</span> err;
00681 }
00682 
00683 
00684 <span class="keyword">static</span> <a class="code" href="structcfs__fileid.html">cfs_fileid</a> *openfd=NULL;
00685 <span class="keyword">static</span> <span class="keywordtype">int</span> curmode=0700;
00686 <span class="keyword">static</span> <span class="keywordtype">int</span> curfd= -1;
00687 
00688 <span class="comment">/* open file descriptor for handle.  maintains cache of one fd */</span>
00689 <span class="keywordtype">int</span>
00690 <a class="code" href="cfs__fh_8c.html#a40">fhtofd</a>(f,mode)
00691      <a class="code" href="structcfs__fileid.html">cfs_fileid</a> *f;
<a name="l00692"></a><a class="code" href="cfs__fh_8c.html#a21">00692</a>      <span class="keywordtype">int</span> <a class="code" href="cfs__fh_8c.html#a21">mode</a>;
00693 {
00694         <span class="keywordtype">int</span> <a class="code" href="cfs__fh_8c.html#a8">fd</a>;
00695 
00696 <span class="preprocessor">#ifdef DEBUG</span>
00697 <span class="preprocessor"></span>        fprintf(stderr,<span class="stringliteral">"Translating %s\n"</span>,f-&gt;name);
00698 <span class="preprocessor">#endif</span>
00699 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (f==NULL) {
00700                 <a class="code" href="cfs_8h.html#a30">cfserrno</a>=NFSERR_STALE;
00701                 <span class="keywordflow">return</span> -2;
00702         }
00703         <span class="keywordflow">if</span> (curfd&gt;=0) { <span class="comment">/* it's open already */</span>
00704                 <span class="keywordflow">if</span> ((openfd==f) &amp;&amp; (curmode==<a class="code" href="cfs__fh_8c.html#a21">mode</a>)) <span class="comment">/* yay */</span>
00705                         <span class="keywordflow">return</span> curfd;
00706                 close(curfd);   <span class="comment">/* hope it was valid... */</span>
00707                 openfd=NULL;
00708         }
00709 
00710         <span class="keywordflow">if</span> (<a class="code" href="cfs__fh_8c.html#a21">mode</a>==0) { <a class="code" href="cfs__fh_8c.html#a21">mode</a>=<a class="code" href="cfs_8h.html#a20">CFS_WRITE</a>; }
00711         <span class="comment">/* Phil Karn's hack for R/O file systems */</span>
00712         <span class="keywordflow">if</span> ((<a class="code" href="cfs__fh_8c.html#a8">fd</a>=open(f-&gt;name,<a class="code" href="cfs__fh_8c.html#a21">mode</a>,0))&lt;0 &amp;&amp; <a class="code" href="cfs_8h.html#a31">errno</a> == EROFS) {
00713                 <a class="code" href="cfs__fh_8c.html#a21">mode</a> = <a class="code" href="cfs_8h.html#a19">CFS_READ</a>;        <span class="comment">/* Force read and try again */</span>
00714                 <a class="code" href="cfs__fh_8c.html#a8">fd</a> = open(f-&gt;name,<a class="code" href="cfs__fh_8c.html#a21">mode</a>,0);
00715         }
00716 
00717         <span class="keywordflow">if</span>(<a class="code" href="cfs__fh_8c.html#a8">fd</a>&lt;0) {
00718                 <a class="code" href="cfs_8h.html#a30">cfserrno</a>=cfsno(<a class="code" href="cfs_8h.html#a31">errno</a>);
00719                 <span class="keywordflow">if</span> ((<a class="code" href="cfs_8h.html#a31">errno</a> == EACCES) &amp;&amp; (<a class="code" href="cfs__fh_8c.html#a21">mode</a>==<a class="code" href="cfs_8h.html#a20">CFS_WRITE</a>)) { <span class="comment">/* ugly hack */</span>
00720                         <span class="keywordtype">int</span> omode;
00721 
00722                         omode=modeof(f-&gt;name);
00723                         <span class="keywordflow">if</span> (omode&lt;0)
00724                                 <span class="keywordflow">return</span> -2;
00725                         chmod(f-&gt;name,0700);
00726                         <a class="code" href="cfs__fh_8c.html#a8">fd</a>=open(f-&gt;name,<a class="code" href="cfs__fh_8c.html#a21">mode</a>,0);
00727                         chmod(f-&gt;name,omode);
00728                         <span class="keywordflow">if</span> (<a class="code" href="cfs__fh_8c.html#a8">fd</a>&lt;0)
00729                                 <span class="keywordflow">return</span> -2;
00730                 } <span class="keywordflow">else</span> <span class="keywordflow">return</span> -2;
00731         }
00732         <span class="comment">/* now we have to make sure the vect didn't slide out from under us */</span>
00733         <span class="comment">/* check for a linkfile */</span>
00734         <span class="keywordflow">if</span> (readlink(f-&gt;vectname,f-&gt;vect,9) != 8)
00735                 bcopy((<span class="keywordtype">char</span> *)<a class="code" href="ccat_8c.html#a1">zerovect</a>,(<span class="keywordtype">char</span> *)f-&gt;vect,8);
00736         curfd=<a class="code" href="cfs__fh_8c.html#a8">fd</a>;
00737         curmode=<a class="code" href="cfs__fh_8c.html#a21">mode</a>;
00738         openfd=f;
00739         <span class="keywordflow">return</span> <a class="code" href="cfs__fh_8c.html#a8">fd</a>;
00740 }
00741 
00742 <span class="keywordtype">int</span>
00743 modeof(s)
00744      <span class="keywordtype">char</span> *<a class="code" href="cfs__fh_8c.html#a0">s</a>;
00745 {
00746         <span class="keyword">struct </span>stat <a class="code" href="cfs__fh_8c.html#a25">sb</a>;
00747 
00748         <span class="keywordflow">if</span> (lstat(s,&amp;sb)&lt;0)
00749                 <span class="keywordflow">return</span> -1;
00750         <span class="keywordflow">return</span>((<span class="keywordtype">int</span>)<a class="code" href="cfs__fh_8c.html#a25">sb</a>.st_mode);
00751 }
00752 
00753 <span class="keywordtype">int</span>
00754 fhgetstat(h,sb)
00755      <a class="code" href="structcfs__fileid.html">cfs_fileid</a> *<a class="code" href="cfs__fh_8c.html#a28">h</a>;
<a name="l00756"></a><a class="code" href="cfs__fh_8c.html#a25">00756</a>      <span class="keyword">struct </span>stat *<a class="code" href="cfs__fh_8c.html#a25">sb</a>;
00757 {
00758         <span class="keywordflow">if</span> (<a class="code" href="cfs__fh_8c.html#a28">h</a> == NULL) {
00759                 <a class="code" href="cfs_8h.html#a30">cfserrno</a>=NFSERR_STALE;
00760                 <span class="keywordflow">return</span> -2;
00761         }
00762         <span class="comment">/* lstat is correct even for instance roots, since their names</span>
00763 <span class="comment">           end in /. */</span>
00764         <span class="keywordflow">if</span> (lstat(<a class="code" href="cfs__fh_8c.html#a28">h</a>-&gt;name,<a class="code" href="cfs__fh_8c.html#a25">sb</a>)&lt;0)
00765                 <span class="keywordflow">return</span> -1;
00766         <a class="code" href="cfs__fh_8c.html#a25">sb</a>-&gt;st_size=dtov(<a class="code" href="cfs__fh_8c.html#a25">sb</a>-&gt;st_size); <span class="comment">/* tweek size */</span>
00767         <span class="keywordflow">return</span> 0;
00768 }
00769 
00770 closeout(f)
00771      <a class="code" href="structcfs__fileid.html">cfs_fileid</a> *f;
00772 {
00773         <span class="keywordflow">if</span> (openfd==f) {
00774                 <span class="keywordflow">if</span> (curfd&gt;=0)
00775                         close(curfd);
00776                 openfd=NULL;
00777                 curfd = -1;
00778         }
00779 }
00780 
00781 closeall()
00782 {
00783         <span class="keywordflow">if</span> (openfd!=NULL) {
00784                 <span class="keywordflow">if</span> (curfd&gt;=0)
00785                         close(curfd);
00786                 openfd=NULL;
00787                 curfd = -1;
00788         }
00789 }
00790 
00791 fhsetattr(f,a)
00792      <a class="code" href="structcfs__fileid.html">cfs_fileid</a> *f;
00793      sattr *<a class="code" href="cfs__fh_8c.html#a26">a</a>;
00794 {
00795         <span class="keyword">struct </span>timeval tv[2];
00796         <span class="keyword">struct </span>stat <a class="code" href="cfs__fh_8c.html#a25">sb</a>;
00797         
00798         <span class="keywordflow">if</span> (f==NULL) {
00799                 <a class="code" href="cfs_8h.html#a30">cfserrno</a>=NFSERR_STALE;
00800                 <span class="keywordflow">return</span> -2;
00801         }
00802         <span class="keywordflow">if</span> (f-&gt;<a class="code" href="structcfs__fileid.html#o0">fileid</a>==0) { <span class="comment">/* disallow on instance roots */</span>
00803                 <a class="code" href="cfs_8h.html#a30">cfserrno</a>=NFSERR_PERM;
00804                 <span class="keywordflow">return</span> -2;
00805         }
00806         <span class="keywordflow">if</span> (<a class="code" href="cfs__fh_8c.html#a26">a</a>==NULL) <span class="comment">/* i dunno */</span>
00807                 <span class="keywordflow">return</span> 0;
00808         <span class="keywordflow">if</span> ((<a class="code" href="cfs__fh_8c.html#a26">a</a>-&gt;mode&amp;0177777) != 0177777) {
00809                 <span class="keywordflow">if</span> (chmod(f-&gt;<a class="code" href="structcfs__fileid.html#o4">name</a>,<a class="code" href="cfs__fh_8c.html#a26">a</a>-&gt;mode&amp;0177777)&lt;0)
00810                         <span class="keywordflow">return</span> -1;
00811         }
00812         <span class="keywordflow">if</span> (((<span class="keywordtype">int</span>)<a class="code" href="cfs__fh_8c.html#a26">a</a>-&gt;atime.seconds&gt;=0) || ((<span class="keywordtype">int</span>)<a class="code" href="cfs__fh_8c.html#a26">a</a>-&gt;mtime.seconds&gt;=0)) {
00813                 <span class="keywordflow">if</span> ((<span class="keywordtype">int</span>)<a class="code" href="cfs__fh_8c.html#a26">a</a>-&gt;atime.seconds&lt;0) {
00814                         lstat(f-&gt;<a class="code" href="structcfs__fileid.html#o4">name</a>,&amp;sb);
00815                         tv[0].tv_sec=<a class="code" href="cfs__fh_8c.html#a25">sb</a>.st_atime;
00816                         tv[0].tv_usec=0;
00817                 } <span class="keywordflow">else</span> {
00818                         tv[0].tv_sec=<a class="code" href="cfs__fh_8c.html#a26">a</a>-&gt;atime.seconds;
00819                         tv[0].tv_usec=<a class="code" href="cfs__fh_8c.html#a26">a</a>-&gt;atime.useconds;
00820                 }
00821                 <span class="keywordflow">if</span> ((<span class="keywordtype">int</span>)<a class="code" href="cfs__fh_8c.html#a26">a</a>-&gt;mtime.seconds&lt;0) {
00822                         lstat(f-&gt;<a class="code" href="structcfs__fileid.html#o4">name</a>,&amp;sb);
00823                         tv[1].tv_sec=<a class="code" href="cfs__fh_8c.html#a25">sb</a>.st_mtime;
00824                         tv[1].tv_usec=0;
00825                 } <span class="keywordflow">else</span> {
00826                         tv[1].tv_sec=<a class="code" href="cfs__fh_8c.html#a26">a</a>-&gt;mtime.seconds;
00827                         tv[1].tv_usec=<a class="code" href="cfs__fh_8c.html#a26">a</a>-&gt;mtime.useconds;
00828                 }
00829                 <span class="keywordflow">if</span> (utimes(f-&gt;<a class="code" href="structcfs__fileid.html#o4">name</a>,tv)&lt;0)
00830                         <span class="keywordflow">return</span> -1;
00831         }
00832         <span class="keywordflow">if</span> (((<span class="keywordtype">int</span>)<a class="code" href="cfs__fh_8c.html#a26">a</a>-&gt;size) &gt;= 0)
00833                 <span class="keywordflow">if</span> (truncate(f-&gt;<a class="code" href="structcfs__fileid.html#o4">name</a>,vtod(<a class="code" href="cfs__fh_8c.html#a26">a</a>-&gt;size)))
00834                         <span class="keywordflow">if</span> (<a class="code" href="cfs_8h.html#a31">errno</a> != EISDIR)
00835                                 <span class="keywordflow">return</span> 0;
00836 <span class="comment">/*      printf("fhsetattr: atime=%x,%x  mtime=%x,%x\n",</span>
00837 <span class="comment">               a-&gt;atime.seconds, a-&gt;atime.useconds,</span>
00838 <span class="comment">               a-&gt;mtime.seconds, a-&gt;mtime.useconds); */</span>
00839         <span class="keywordflow">return</span> 0;
00840 }
00841 
00842 <span class="keywordtype">int</span>
00843 fhsetattrprime(f,a)
00844      <a class="code" href="structcfs__fileid.html">cfs_fileid</a> *f;
<a name="l00845"></a><a class="code" href="cfs__fh_8c.html#a26">00845</a>      sattr *<a class="code" href="cfs__fh_8c.html#a26">a</a>;
00846 {
00847         <span class="keyword">struct </span>timeval tv[2];
00848         <span class="keyword">struct </span>stat <a class="code" href="cfs__fh_8c.html#a25">sb</a>;
00849         
00850         <span class="keywordflow">if</span> (f==NULL) {
00851                 <a class="code" href="cfs_8h.html#a30">cfserrno</a>=NFSERR_STALE;
00852                 <span class="keywordflow">return</span> -2;
00853         }
00854         <span class="keywordflow">if</span> (f-&gt;fileid==0) { <span class="comment">/* disallow on instance roots */</span>
00855                 <a class="code" href="cfs_8h.html#a30">cfserrno</a>=NFSERR_PERM;
00856                 <span class="keywordflow">return</span> -2;
00857         }
00858         <span class="keywordflow">if</span> (<a class="code" href="cfs__fh_8c.html#a26">a</a>==NULL) <span class="comment">/* i dunno */</span>
00859                 <span class="keywordflow">return</span> 0;
00860         <span class="comment">/* same as above, modulo the chmod */</span>
00861         <span class="keywordflow">if</span> (((<span class="keywordtype">int</span>)<a class="code" href="cfs__fh_8c.html#a26">a</a>-&gt;atime.seconds&gt;=0) || ((<span class="keywordtype">int</span>)<a class="code" href="cfs__fh_8c.html#a26">a</a>-&gt;mtime.seconds&gt;=0)) {
00862                 <span class="keywordflow">if</span> ((<span class="keywordtype">int</span>)<a class="code" href="cfs__fh_8c.html#a26">a</a>-&gt;atime.seconds&lt;0) {
00863                         lstat(f-&gt;name,&amp;<a class="code" href="cfs__fh_8c.html#a25">sb</a>);
00864                         tv[0].tv_sec=<a class="code" href="cfs__fh_8c.html#a25">sb</a>.st_atime;
00865                         tv[0].tv_usec=0;
00866                 } <span class="keywordflow">else</span> {
00867                         tv[0].tv_sec=<a class="code" href="cfs__fh_8c.html#a26">a</a>-&gt;atime.seconds;
00868                         tv[0].tv_usec=<a class="code" href="cfs__fh_8c.html#a26">a</a>-&gt;atime.useconds;
00869                 }
00870                 <span class="keywordflow">if</span> ((<span class="keywordtype">int</span>)<a class="code" href="cfs__fh_8c.html#a26">a</a>-&gt;mtime.seconds&lt;0) {
00871                         lstat(f-&gt;name,&amp;<a class="code" href="cfs__fh_8c.html#a25">sb</a>);
00872                         tv[1].tv_sec=<a class="code" href="cfs__fh_8c.html#a25">sb</a>.st_mtime;
00873                         tv[1].tv_usec=0;
00874                 } <span class="keywordflow">else</span> {
00875                         tv[1].tv_sec=<a class="code" href="cfs__fh_8c.html#a26">a</a>-&gt;mtime.seconds;
00876                         tv[1].tv_usec=<a class="code" href="cfs__fh_8c.html#a26">a</a>-&gt;mtime.useconds;
00877                 }
00878                 <span class="keywordflow">if</span> (utimes(f-&gt;name,tv)&lt;0)
00879                         <span class="keywordflow">return</span> -1;
00880         }
00881         <span class="keywordflow">if</span> (((<span class="keywordtype">int</span>)<a class="code" href="cfs__fh_8c.html#a26">a</a>-&gt;size) &gt;= 0)
00882                 <span class="keywordflow">if</span> (truncate(f-&gt;name,vtod(<a class="code" href="cfs__fh_8c.html#a26">a</a>-&gt;size)))
00883                         <span class="keywordflow">if</span> (<a class="code" href="cfs_8h.html#a31">errno</a> != EISDIR)
00884                                 <span class="keywordflow">return</span> 0;
00885         <span class="keywordflow">return</span> 0;
00886 }
00887 
00888 fhmkdirent(p,comp,h)
00889      <a class="code" href="structcfs__fileid.html">cfs_fileid</a> *p;
00890      <span class="keywordtype">char</span> *<a class="code" href="cfs__fh_8c.html#a27">comp</a>;
00891      <a class="code" href="structfhdata.html">fhdata</a> *<a class="code" href="cfs__fh_8c.html#a28">h</a>;
00892 {
00893         <span class="keywordtype">char</span> path[NFS_MAXPATHLEN+1];
00894         <span class="keyword">struct </span>stat <a class="code" href="cfs__fh_8c.html#a25">sb</a>;
00895         
00896         <span class="keywordflow">if</span> (p==NULL) {
00897                 <a class="code" href="cfs_8h.html#a30">cfserrno</a>=NFSERR_STALE;
00898                 <span class="keywordflow">return</span> -2;
00899         }
00900         sprintf(path,<span class="stringliteral">"%s/%s"</span>,p-&gt;<a class="code" href="structcfs__fileid.html#o4">name</a>,comp);
00901         <span class="keywordflow">if</span> (mkdir(path,0)&lt;0)
00902                 <span class="keywordflow">return</span> -1;
00903         <span class="keywordflow">if</span> (stat(path,&amp;sb)&lt;0)
00904                 <span class="keywordflow">return</span> -1;
00905         <span class="keywordflow">return</span> (mkhandle(p,path,comp,<a class="code" href="cfs__fh_8c.html#a25">sb</a>.st_ino,h,zerovect,<span class="stringliteral">"/NOWHERE/null"</span>
00906 #ifdef SHORTLINKS
00907                                                                          ,FALSE
00908 #endif <span class="comment">/* SHORTLINKS */</span>
00909                                                                          ));
00910 }
00911 
00912 <span class="keywordtype">int</span>
00913 fhmkfileent(p,comp,h)
00914      <a class="code" href="structcfs__fileid.html">cfs_fileid</a> *p;
00915      <span class="keywordtype">char</span> *<a class="code" href="cfs__fh_8c.html#a27">comp</a>;
00916      <a class="code" href="structfhdata.html">fhdata</a> *<a class="code" href="cfs__fh_8c.html#a28">h</a>;
00917 {
00918         <span class="keywordtype">char</span> path[NFS_MAXPATHLEN+1];
00919         <span class="keywordtype">int</span> <a class="code" href="cfs__fh_8c.html#a8">fd</a>;
00920         <span class="keyword">struct </span>stat <a class="code" href="cfs__fh_8c.html#a25">sb</a>;
00921         <span class="keywordtype">int</span> <a class="code" href="esm_8h.html#a6">rs</a>=0;
00922         <span class="keywordtype">int</span> m;
00923         <span class="keywordtype">char</span> <a class="code" href="cfs__fh_8c.html#a12">vect</a>[9];
00924         <span class="keyword">union</span>{
00925                 u_char ch[9];
00926                 u_long i[2];
00927         } <a class="code" href="cfs__fh_8c.html#a34">buf</a>;
00928         <span class="keywordtype">char</span> linkname[NFS_MAXPATHLEN+1];
00929         
00930         <span class="keywordflow">if</span> (p==NULL) {
00931                 <a class="code" href="cfs_8h.html#a30">cfserrno</a>=NFSERR_STALE;
00932                 <span class="keywordflow">return</span> -2;
00933         }
00934         sprintf(path,<span class="stringliteral">"%s/%s"</span>,p-&gt;name,comp);
00935 
00936         <span class="keywordflow">if</span> ((<a class="code" href="cfs__fh_8c.html#a8">fd</a>=open(path,O_CREAT|O_WRONLY|O_EXCL,0))&lt;0) {
00937                 <span class="keywordflow">if</span> (<a class="code" href="cfs_8h.html#a31">errno</a>==EEXIST) {
00938                         <span class="keywordflow">if</span> ((<a class="code" href="cfs__fh_8c.html#a8">fd</a>=open(path,O_WRONLY,0))&lt;0)
00939                                 <span class="keywordflow">return</span> -1;
00940                         <span class="keywordflow">else</span>
00941                                 <a class="code" href="esm_8h.html#a6">rs</a>=1;
00942                 } <span class="keywordflow">else</span>
00943                         <span class="keywordflow">return</span> -1;
00944         }
00945         <span class="keywordflow">if</span> (fstat(fd,&amp;sb)&lt;0)
00946                 <span class="keywordflow">return</span> -1;
00947         close(fd);
00948         sprintf(linkname,<span class="stringliteral">"%s/.pvect_%s"</span>,p-&gt;name,comp);
00949         <span class="keywordflow">if</span> (!<a class="code" href="esm_8h.html#a6">rs</a>) {
00950            <span class="keywordflow">if</span> (p-&gt;ins-&gt;highsec) {       <span class="comment">/* create new pert file iff highsec */</span>
00951                 <span class="comment">/* note that there's a race condition here until the simlink */</span>
00952                 <span class="comment">/*</span>
00953 <span class="comment">                sprintf((char *)buf,"%08x",(u_long)sb.st_ino+(u_long)sb.st_ctime);</span>
00954 <span class="comment">                */</span>
00955                 <a class="code" href="cfs__fh_8c.html#a34">buf</a>.i[0]=(u_long)<a class="code" href="cfs__fh_8c.html#a25">sb</a>.st_ino;
00956                 <a class="code" href="cfs__fh_8c.html#a34">buf</a>.i[1]=(u_long)<a class="code" href="cfs__fh_8c.html#a25">sb</a>.st_ctime;
00957                 <a class="code" href="cfs__des_8c.html#a64">q_block_cipher</a>(<span class="stringliteral">"fixedkey"</span>,&amp;buf,1);
00958                 <span class="comment">/* des is just used here as a hash fn to spread the bits */</span>
00959                 <span class="comment">/* since we only use 32 bits of the result, its a nonperfect */</span>
00960                 <span class="comment">/* hash. but this doesn't really matter since collisions */</span>
00961                 <span class="comment">/* are rare.  we could save all 64 bits, but the encoding */</span>
00962                 <span class="comment">/* of the link would get messy and large */</span>
00963                 sprintf(vect,<span class="stringliteral">"%02x%02x%02x%02x"</span>,
00964                         <a class="code" href="cfs__fh_8c.html#a34">buf</a>.ch[0],<a class="code" href="cfs__fh_8c.html#a34">buf</a>.ch[1],<a class="code" href="cfs__fh_8c.html#a34">buf</a>.ch[2],<a class="code" href="cfs__fh_8c.html#a34">buf</a>.ch[3]);
00965                 <span class="keywordflow">if</span> (symlink(vect,linkname) != 0) {
00966                         strcpy(linkname,<span class="stringliteral">"/NOWHERE/null"</span>);
00967                         bcopy((<span class="keywordtype">char</span> *)zerovect,(<span class="keywordtype">char</span> *)vect,8);
00968                 }
00969            } <span class="keywordflow">else</span> {
00970                 unlink(linkname);
00971                 bcopy((<span class="keywordtype">char</span> *)zerovect,(<span class="keywordtype">char</span> *)vect,8);
00972                 strcpy(linkname,<span class="stringliteral">"/NOWHERE/null"</span>);
00973            }
00974         } <span class="keywordflow">else</span> {
00975                 <span class="keywordflow">if</span> (readlink(linkname,vect,9) != 8) {
00976                         bcopy((<span class="keywordtype">char</span> *)zerovect,(<span class="keywordtype">char</span> *)vect,8);
00977                         strcpy(linkname,<span class="stringliteral">"/NOWHERE/null"</span>);
00978                 }
00979                 <span class="keywordflow">else</span> <a class="code" href="cfs__fh_8c.html#a12">vect</a>[8]=<span class="charliteral">'\0'</span>;
00980         }
00981         m=mkhandle(p,path,comp,<a class="code" href="cfs__fh_8c.html#a25">sb</a>.st_ino,h,vect,linkname
00982 #ifdef SHORTLINKS
00983                                                         ,FALSE
00984 #endif <span class="comment">/* SHORTLINKS */</span>
00985                                                         );
00986         <span class="keywordflow">if</span> (m!=0)
00987                 <span class="keywordflow">return</span> m;
00988         <span class="keywordflow">return</span> <a class="code" href="esm_8h.html#a6">rs</a>;
00989 }
00990 
00991 
00992 <span class="keywordtype">int</span>
00993 fhlook(p,comp,h)
00994      <a class="code" href="structcfs__fileid.html">cfs_fileid</a> *p;
00995      <span class="keywordtype">char</span> *<a class="code" href="cfs__fh_8c.html#a27">comp</a>;
00996      <a class="code" href="structfhdata.html">fhdata</a> *<a class="code" href="cfs__fh_8c.html#a28">h</a>;
00997 {
00998         <span class="keywordtype">char</span> path[NFS_MAXPATHLEN+1];
00999         <span class="keywordtype">char</span> linkname[NFS_MAXPATHLEN+1];
01000         <span class="keywordtype">char</span> <a class="code" href="cfs__fh_8c.html#a12">vect</a>[NFS_MAXPATHLEN+1];
01001         <span class="keyword">struct </span>stat <a class="code" href="cfs__fh_8c.html#a25">sb</a>;
01002         
01003         <span class="keywordflow">if</span> (p==NULL) {
01004                 <a class="code" href="cfs_8h.html#a30">cfserrno</a>=NFSERR_STALE;
01005                 <span class="keywordflow">return</span> -2;
01006         }
01007         <span class="keywordflow">if</span> (p-&gt;fileid==0) {
01008                 <span class="keywordflow">if</span> (!strcmp(comp,<span class="stringliteral">"."</span>))
01009                         <span class="keywordflow">return</span> fhrootlook(p-&gt;ins-&gt;name,h);
01010                 <span class="keywordflow">if</span> (!strcmp(comp,<span class="stringliteral">".."</span>))
01011                         <span class="keywordflow">return</span> fhrootlook(<span class="stringliteral">"."</span>,h);
01012         }
01013         <span class="keywordflow">if</span> ((p-&gt;parent==0) &amp;&amp; (!strcmp(comp,<span class="stringliteral">".."</span>)))
01014                 <span class="keywordflow">return</span> fhrootlook(p-&gt;ins-&gt;name,h);
01015         sprintf(path,<span class="stringliteral">"%s/%s"</span>,p-&gt;name,comp);
01016         <span class="keywordflow">if</span> (lstat(path,&amp;sb)&lt;0) {
01017                 <span class="keywordflow">return</span> -1;      <span class="comment">/* just need the inode */</span>
01018         }
01019         <span class="comment">/* check for a linkfile */</span>
01020         sprintf(linkname,<span class="stringliteral">"%s/.pvect_%s"</span>,p-&gt;name,comp);
01021         <span class="keywordflow">if</span> (readlink(linkname,vect,9) != 8) {
01022                 bcopy((<span class="keywordtype">char</span> *)zerovect,(<span class="keywordtype">char</span> *)vect,8);
01023                 strcpy(linkname,<span class="stringliteral">"/NOWHERE/null"</span>);
01024         }
01025         <span class="keywordflow">else</span> <a class="code" href="cfs__fh_8c.html#a12">vect</a>[8]=<span class="charliteral">'\0'</span>;
01026 <span class="preprocessor">#ifdef SHORTLINKS</span>
01027 <span class="preprocessor"></span>        {
01028                 <span class="keyword">struct </span>stat sp;
01029                 ino_t pino = p-&gt;fileid;
01030                 <span class="keywordflow">if</span> (pino == 0) {
01031                         <span class="keywordflow">if</span> (lstat(p-&gt;name, &amp;sp) == 0)
01032                                 pino = sp.st_ino;
01033                 }
01034                 <span class="keywordflow">return</span> (mkhandle(p,path,comp,<a class="code" href="cfs__fh_8c.html#a25">sb</a>.st_ino,h,vect,linkname,
01035                                  (S_ISLNK(<a class="code" href="cfs__fh_8c.html#a25">sb</a>.st_mode)&amp;&amp;(pino == <a class="code" href="cfs__fh_8c.html#a25">sb</a>.st_ino))));
01036         }
01037 <span class="preprocessor">#else </span><span class="comment">/* SHORTLINKS */</span>
01038         <span class="keywordflow">return</span> (mkhandle(p,path,comp,<a class="code" href="cfs__fh_8c.html#a25">sb</a>.st_ino,h,vect,linkname));
01039 <span class="preprocessor">#endif </span><span class="comment">/* SHORTLINKS */</span>
01040 }
01041 
01042 
01043 <span class="keywordtype">int</span>
01044 mkhandle(p,n,comp,ino,h,vect,vectname
01045 #ifdef SHORTLINKS
01046                                      ,isl)
01047      <span class="keywordtype">int</span> isl;   <span class="comment">/* is short link */</span>
01048 <span class="preprocessor">#else </span><span class="comment">/* SHORTLINKS */</span>
01049                                      )
01050 <span class="preprocessor">#endif </span><span class="comment">/* SHORTLINKS */</span>
01051      <a class="code" href="structcfs__fileid.html">cfs_fileid</a> *p;
01052      <span class="keywordtype">char</span> *<a class="code" href="shs_8c.html#a29">n</a>;
<a name="l01053"></a><a class="code" href="cfs__fh_8c.html#a27">01053</a>      <span class="keywordtype">char</span> *<a class="code" href="cfs__fh_8c.html#a27">comp</a>;
01054      <span class="keywordtype">int</span> <a class="code" href="cfs__fh_8c.html#a30">ino</a>;
01055      <a class="code" href="structfhdata.html">fhdata</a> *<a class="code" href="cfs__fh_8c.html#a28">h</a>;
<a name="l01056"></a><a class="code" href="cfs__fh_8c.html#a12">01056</a>      <span class="keywordtype">char</span> *<a class="code" href="cfs__fh_8c.html#a12">vect</a>;
<a name="l01057"></a><a class="code" href="cfs__fh_8c.html#a31">01057</a>      <span class="keywordtype">char</span> *<a class="code" href="cfs__fh_8c.html#a31">vectname</a>;
01058 {
01059         <a class="code" href="structcfs__fileid.html">cfs_fileid</a> *f;
01060 
01061 <span class="preprocessor">#ifdef SHORTLINKS</span>
01062 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (!isl &amp;&amp; ((f=findh(<a class="code" href="cfs__fh_8c.html#a30">ino</a>,p-&gt;<a class="code" href="structcfs__fileid.html#o8">ins</a>-&gt;<a class="code" href="structinstance.html#o6">id</a>,0)) != NULL)) {
01063 <span class="preprocessor">#else </span><span class="comment">/* SHORTLINKS */</span>
01064         <span class="keywordflow">if</span> ((f=findh(<a class="code" href="cfs__fh_8c.html#a30">ino</a>,p-&gt;<a class="code" href="structcfs__fileid.html#o8">ins</a>-&gt;<a class="code" href="structinstance.html#o6">id</a>)) != NULL) {
01065 <span class="preprocessor">#endif </span><span class="comment">/* SHORTLINKS */</span>
01066                 <span class="keywordflow">if</span> (strcmp(<a class="code" href="cfs__fh_8c.html#a27">comp</a>,<span class="stringliteral">"."</span>) &amp;&amp; strcmp(<a class="code" href="cfs__fh_8c.html#a27">comp</a>,<span class="stringliteral">".."</span>)) {
01067                         free(f-&gt;name);
01068                         f-&gt;name=NULL;
01069                 }
01070         } <span class="keywordflow">else</span> {
01071                 <span class="keywordflow">if</span> ((f=(<a class="code" href="structcfs__fileid.html">cfs_fileid</a> *)malloc(<span class="keyword">sizeof</span>(<a class="code" href="structcfs__fileid.html">cfs_fileid</a>)))==NULL) {
01072                         fprintf(stderr,<span class="stringliteral">"cfsd: out of memory\n"</span>);
01073                         <a class="code" href="cfs_8h.html#a30">cfserrno</a>=NFSERR_STALE;  <span class="comment">/* bad news */</span>
01074                         <span class="keywordflow">return</span> -2;
01075                 }
01076                 f-&gt;fileid=<a class="code" href="cfs__fh_8c.html#a30">ino</a>;
01077                 f-&gt;parent=p-&gt;<a class="code" href="structcfs__fileid.html#o0">fileid</a>;    <span class="comment">/* only need for directory */</span>
01078 <span class="preprocessor">#ifdef SHORTLINKS</span>
01079 <span class="preprocessor"></span>                f-&gt;link_count = 0;      <span class="comment">/* Always start at zero */</span>
01080                 <span class="keywordflow">if</span> (isl)
01081                         f-&gt;linkid = ++p-&gt;link_count;
01082                 <span class="keywordflow">else</span>
01083                         f-&gt;linkid = 0;
01084 <span class="preprocessor">#endif </span><span class="comment">/* SHORTLINKS */</span>
01085                 f-&gt;<a class="code" href="structcfs__fileid.html#o8">ins</a>=p-&gt;<a class="code" href="structcfs__fileid.html#o8">ins</a>;
01086                 f-&gt;<a class="code" href="structinstance.html#o2">name</a>=NULL;
01087                 inserth(f);
01088         }
01089         <span class="keywordflow">if</span> (f-&gt;name==NULL) {
01090                 <span class="keywordflow">if</span> ((f-&gt;name=(<span class="keywordtype">char</span> *)malloc(strlen(<a class="code" href="shs_8c.html#a29">n</a>)+1)) ==NULL) {
01091                         fprintf(stderr,<span class="stringliteral">"cfsd: out of memory\n"</span>);
01092                         <a class="code" href="cfs_8h.html#a30">cfserrno</a>=NFSERR_STALE;
01093                         <span class="keywordflow">return</span> -2;
01094                 }
01095                 strcpy(f-&gt;name,<a class="code" href="shs_8c.html#a29">n</a>);
01096                 strcpy(f-&gt;vectname,<a class="code" href="cfs__fh_8c.html#a31">vectname</a>);
01097                 bcopy((<span class="keywordtype">char</span> *)<a class="code" href="cfs__fh_8c.html#a12">vect</a>,(<span class="keywordtype">char</span> *)f-&gt;vect,8);
01098                 f-&gt;vect[8]=<span class="charliteral">'\0'</span>;
01099         }
01100         <span class="keywordflow">if</span> (<a class="code" href="cfs__fh_8c.html#a28">h</a>!=NULL) {
01101                 fillinh(<a class="code" href="cfs__fh_8c.html#a28">h</a>,p-&gt;<a class="code" href="structcfs__fileid.html#o8">ins</a>-&gt;<a class="code" href="structinstance.html#o6">id</a>,<a class="code" href="cfs__fh_8c.html#a30">ino</a>,p-&gt;<a class="code" href="structcfs__fileid.html#o8">ins</a>-&gt;<a class="code" href="structinstance.html#o4">check</a>);
01102 <span class="preprocessor">#ifdef SHORTLINKS</span>
01103 <span class="preprocessor"></span>                <a class="code" href="cfs__fh_8c.html#a28">h</a>-&gt;linkid = f-&gt;linkid;
01104                 <span class="keywordflow">if</span> (isl)
01105                         <a class="code" href="cfs__fh_8c.html#a28">h</a>-&gt;<a class="code" href="structfhdata.html#o1">htype</a> = H_SLNK;
01106 <span class="preprocessor">#endif </span><span class="comment">/* SHORTLINKS */</span>
01107         }
01108         <span class="keywordflow">return</span> 0;
01109 }
01110 
01111 inserth(f)
01112      <a class="code" href="structcfs__fileid.html">cfs_fileid</a> *f;
01113 {
01114         u_int bucket;
01115         
01116         bucket=<a class="code" href="cfs__fh_8c.html#a0">hash</a>(f-&gt;<a class="code" href="structcfs__fileid.html#o0">fileid</a>);
01117         f-&gt;<a class="code" href="structcfs__fileid.html#o7">next</a>=<a class="code" href="cfs_8h.html#a35">instances</a>[f-&gt;<a class="code" href="structcfs__fileid.html#o8">ins</a>-&gt;<a class="code" href="structinstance.html#o6">id</a>]-&gt;file[bucket];
01118         <a class="code" href="cfs_8h.html#a35">instances</a>[f-&gt;<a class="code" href="structcfs__fileid.html#o8">ins</a>-&gt;<a class="code" href="structinstance.html#o6">id</a>]-&gt;file[bucket]=f;
01119 }
01120 
01121 fillinh(<a class="code" href="cfs__fh_8c.html#a28">h</a>,<a class="code" href="cfs__fh_8c.html#a32">iid</a>,<a class="code" href="cfs__fh_8c.html#a30">ino</a>,<a class="code" href="cfs__fh_8c.html#a33">check</a>)
01122      <a class="code" href="structfhdata.html">fhdata</a> *<a class="code" href="cfs__fh_8c.html#a28">h</a>;
<a name="l01123"></a><a class="code" href="cfs__fh_8c.html#a32">01123</a>      <span class="keywordtype">int</span> <a class="code" href="cfs__fh_8c.html#a32">iid</a>;
<a name="l01124"></a><a class="code" href="cfs__fh_8c.html#a30">01124</a>      <span class="keywordtype">int</span> <a class="code" href="cfs__fh_8c.html#a30">ino</a>;
<a name="l01125"></a><a class="code" href="cfs__fh_8c.html#a33">01125</a>      <span class="keywordtype">char</span> *<a class="code" href="cfs__fh_8c.html#a33">check</a>;
01126 {
01127         bzero((<span class="keywordtype">char</span> *)<a class="code" href="cfs__fh_8c.html#a28">h</a>,<span class="keyword">sizeof</span>(<a class="code" href="structfhdata.html">fhdata</a>));
01128         bcopy((<span class="keywordtype">char</span> *)magictest,(<span class="keywordtype">char</span> *)<a class="code" href="cfs__fh_8c.html#a28">h</a>-&gt;<a class="code" href="structfhdata.html#o0">magic</a>,<span class="keyword">sizeof</span>(magictest));
01129         bcopy((<span class="keywordtype">char</span> *)<a class="code" href="cfs__fh_8c.html#a33">check</a>,(<span class="keywordtype">char</span> *)<a class="code" href="cfs__fh_8c.html#a28">h</a>-&gt;<a class="code" href="structfhdata.html#o4">check</a>,8);
01130         <a class="code" href="cfs__fh_8c.html#a28">h</a>-&gt;<a class="code" href="structfhdata.html#o1">htype</a>=<a class="code" href="cfs_8h.html#a0">H_REG</a>;
01131         <a class="code" href="cfs__fh_8c.html#a28">h</a>-&gt;<a class="code" href="structfhdata.html#o2">instance</a>=<a class="code" href="cfs__fh_8c.html#a32">iid</a>;
01132         <a class="code" href="cfs__fh_8c.html#a28">h</a>-&gt;<a class="code" href="structfhdata.html#o3">fileid</a>=<a class="code" href="cfs__fh_8c.html#a30">ino</a>;
01133 }
01134 
01135 <span class="keywordtype">int</span>
01136 fhdelete(f,s)
01137      <a class="code" href="structcfs__fileid.html">cfs_fileid</a> *f;
01138      <span class="keywordtype">char</span> *<a class="code" href="cfs__fh_8c.html#a0">s</a>;
01139 {
01140         <span class="keywordtype">char</span> path[NFS_MAXPATHLEN+1];
01141         <span class="keywordtype">char</span> linkname[NFS_MAXPATHLEN+1];
01142         <span class="keywordtype">int</span> ret;
01143 
01144         <span class="keywordflow">if</span> (f==NULL) {
01145                 <a class="code" href="cfs_8h.html#a30">cfserrno</a>=NFSERR_STALE;
01146                 <span class="keywordflow">return</span> -2;
01147         }
01148         sprintf(linkname,<span class="stringliteral">"%s/.pvect_%s"</span>,f-&gt;name,s);
01149         sprintf(path,<span class="stringliteral">"%s/%s"</span>,f-&gt;name,s);
01150         <span class="comment">/* note that we don't bother to check and see if there's a</span>
01151 <span class="comment">           handle allocated for this - just wait for the inode to be</span>
01152 <span class="comment">           reclaimed */</span>
01153         <span class="keywordflow">if</span> ((ret=unlink(path)) == 0)
01154                 unlink(linkname); <span class="comment">/* doesn't matter if link isn't there */</span>
01155         <span class="keywordflow">return</span> (ret);
01156 }
01157 
01158 <span class="keywordtype">int</span>
01159 fhdeletedir(f,s)
01160      <a class="code" href="structcfs__fileid.html">cfs_fileid</a> *f;
<a name="l01161"></a><a class="code" href="cfs__fh_8c.html#a13">01161</a>      <span class="keywordtype">char</span> *<a class="code" href="cfs__fh_8c.html#a0">s</a>;
01162 {
01163         <span class="keywordtype">char</span> path[NFS_MAXPATHLEN+1];
01164 
01165         <span class="keywordflow">if</span> (f==NULL) {
01166                 <a class="code" href="cfs_8h.html#a30">cfserrno</a>=NFSERR_STALE;
01167                 <span class="keywordflow">return</span> -2;
01168         }
01169         sprintf(path,<span class="stringliteral">"%s/%s"</span>,f-&gt;name,<a class="code" href="cfs__fh_8c.html#a0">s</a>);
01170         <span class="keywordflow">return</span> (rmdir(path));
01171 }
01172 
01173 DIR *
01174 fhopendir(d)
01175      <a class="code" href="structcfs__fileid.html">cfs_fileid</a> *<a class="code" href="cfs__cipher_8c.html#a1">d</a>;
01176 {
01177         DIR *dp;
01178         
01179         <span class="keywordflow">if</span> (<a class="code" href="cfs__cipher_8c.html#a1">d</a>==NULL) {
01180                 <a class="code" href="cfs_8h.html#a30">cfserrno</a>=NFSERR_STALE;
01181                 <span class="keywordflow">return</span> NULL;
01182         }
01183         <span class="keywordflow">if</span> ((dp=opendir(<a class="code" href="cfs__cipher_8c.html#a1">d</a>-&gt;name))==NULL)
01184                 <a class="code" href="cfs_8h.html#a30">cfserrno</a>=cfsno(errno);
01185         <span class="keywordflow">return</span> dp;
01186 }
01187 
01188 fhclosedir(dp)
01189      DIR *dp;
01190 {
01191         closedir(dp);
01192 }
01193 
01194 
01195 <span class="keywordtype">int</span>
01196 fhlinkval(f,buf)
01197      <a class="code" href="structcfs__fileid.html">cfs_fileid</a> *f;
<a name="l01198"></a><a class="code" href="cfs__fh_8c.html#a34">01198</a>      <span class="keywordtype">char</span> *<a class="code" href="cfs__fh_8c.html#a34">buf</a>;
01199 {
01200         <span class="keywordflow">if</span> (f==NULL) {
01201                 <a class="code" href="cfs_8h.html#a30">cfserrno</a>=NFSERR_STALE;
01202                 <span class="keywordflow">return</span> -2;
01203         }
01204         <span class="keywordflow">return</span>(readlink(f-&gt;name,<a class="code" href="cfs__fh_8c.html#a34">buf</a>,NFS_MAXNAMLEN));
01205 }
01206 
01207 
01208 <span class="keywordtype">int</span>
01209 fhdohardlink(f,t,n)
01210      <a class="code" href="structcfs__fileid.html">cfs_fileid</a> *f;
01211      <a class="code" href="structcfs__fileid.html">cfs_fileid</a> *<a class="code" href="cfs__fh_8c.html#a35">t</a>;
01212      <span class="keywordtype">char</span> *<a class="code" href="shs_8c.html#a29">n</a>;
01213 {
01214         <span class="keywordtype">char</span> <a class="code" href="cfs__fh_8c.html#a34">buf</a>[NFS_MAXPATHLEN+1];
01215         <span class="keywordtype">char</span> linkname[NFS_MAXPATHLEN+1];
01216         <span class="keywordtype">char</span> vectval[9];
01217         <span class="keywordtype">int</span> ret;
01218         
01219         <span class="keywordflow">if</span> ((f==NULL)||(<a class="code" href="cfs__fh_8c.html#a35">t</a>==NULL)) {
01220                 <a class="code" href="cfs_8h.html#a30">cfserrno</a>=NFSERR_STALE;
01221                 <span class="keywordflow">return</span> -2;
01222         }
01223         sprintf(buf,<span class="stringliteral">"%s/%s"</span>,<a class="code" href="cfs__fh_8c.html#a35">t</a>-&gt;<a class="code" href="structcfs__fileid.html#o4">name</a>,n);
01224         <span class="keywordflow">if</span> ((ret=link(f-&gt;name,buf))!=0)
01225                         <span class="keywordflow">return</span> ret;
01226         sprintf(linkname,<span class="stringliteral">"%s/.pvect_%s"</span>,<a class="code" href="cfs__fh_8c.html#a35">t</a>-&gt;<a class="code" href="structcfs__fileid.html#o4">name</a>,n);
01227         unlink(linkname);
01228         <span class="keywordflow">if</span> (readlink(f-&gt;vectname,vectval,9) == 8) {
01229                 vectval[8]=<span class="charliteral">'\0'</span>;
01230                 symlink(vectval,linkname);
01231         }
01232         <span class="keywordflow">return</span> ret;
01233 }
01234 
01235 <span class="keywordtype">int</span>
01236 fhdosymlink(f,n,t)
01237      <a class="code" href="structcfs__fileid.html">cfs_fileid</a> *f;
01238      <span class="keywordtype">char</span> *<a class="code" href="shs_8c.html#a29">n</a>;
01239      <span class="keywordtype">char</span> *<a class="code" href="cfs__fh_8c.html#a35">t</a>;
01240 {
01241         <span class="keywordtype">char</span> <a class="code" href="cfs__fh_8c.html#a34">buf</a>[NFS_MAXPATHLEN+1];
01242         
01243         <span class="keywordflow">if</span> (f==NULL) {
01244                 <a class="code" href="cfs_8h.html#a30">cfserrno</a>=NFSERR_STALE;
01245                 <span class="keywordflow">return</span> -2;
01246         }
01247         sprintf(buf,<span class="stringliteral">"%s/%s"</span>,f-&gt;name,n);
01248         <span class="keywordflow">return</span> (symlink(t,buf));
01249 }
01250 
01251 <span class="keywordtype">int</span>
01252 fhrename(f,fn,t,tn)
01253      <a class="code" href="structcfs__fileid.html">cfs_fileid</a> *f;
<a name="l01254"></a><a class="code" href="cfs__fh_8c.html#a36">01254</a>      <span class="keywordtype">char</span> *<a class="code" href="cfs__fh_8c.html#a36">fn</a>;
<a name="l01255"></a><a class="code" href="cfs__fh_8c.html#a35">01255</a>      <a class="code" href="structcfs__fileid.html">cfs_fileid</a> *<a class="code" href="cfs__fh_8c.html#a35">t</a>;
<a name="l01256"></a><a class="code" href="cfs__fh_8c.html#a37">01256</a>      <span class="keywordtype">char</span> *<a class="code" href="cfs__fh_8c.html#a37">tn</a>;
01257 {
01258         <span class="keywordtype">char</span> fb[NFS_MAXPATHLEN+1];
01259         <span class="keywordtype">char</span> tb[NFS_MAXPATHLEN+1];
01260         <span class="keywordtype">char</span> fblink[NFS_MAXPATHLEN+1];
01261         <span class="keywordtype">char</span> tblink[NFS_MAXPATHLEN+1];
01262         <span class="keywordtype">char</span> vectval[9];
01263         
01264         <span class="keywordflow">if</span> ((f==NULL)||(<a class="code" href="cfs__fh_8c.html#a35">t</a>==NULL)) {
01265                 <a class="code" href="cfs_8h.html#a30">cfserrno</a>=NFSERR_STALE;
01266                 <span class="keywordflow">return</span> -2;
01267         }
01268         sprintf(fb,<span class="stringliteral">"%s/%s"</span>,f-&gt;name,<a class="code" href="cfs__fh_8c.html#a36">fn</a>);
01269         sprintf(tb,<span class="stringliteral">"%s/%s"</span>,<a class="code" href="cfs__fh_8c.html#a35">t</a>-&gt;<a class="code" href="structcfs__fileid.html#o4">name</a>,<a class="code" href="cfs__fh_8c.html#a37">tn</a>);
01270         sprintf(fblink,<span class="stringliteral">"%s/.pvect_%s"</span>,f-&gt;name,<a class="code" href="cfs__fh_8c.html#a36">fn</a>);
01271         sprintf(tblink,<span class="stringliteral">"%s/.pvect_%s"</span>,<a class="code" href="cfs__fh_8c.html#a35">t</a>-&gt;<a class="code" href="structcfs__fileid.html#o4">name</a>,<a class="code" href="cfs__fh_8c.html#a37">tn</a>);
01272         <span class="keywordflow">if</span> (rename(fb,tb)==0) { <span class="comment">/* now we have to do a lookup */</span>
01273                 unlink(tblink); <span class="comment">/* may be a quick race cndtn here */</span>
01274                 <span class="keywordflow">if</span> (readlink(fblink,vectval,9)==8) {
01275                         vectval[8]=<span class="charliteral">'\0'</span>;
01276                         symlink(vectval,tblink);
01277                 }
01278                 unlink(fblink);
01279                 <span class="comment">/* rename(fblink,tblink); */</span>
01280                 fhlook(<a class="code" href="cfs__fh_8c.html#a35">t</a>,<a class="code" href="cfs__fh_8c.html#a37">tn</a>,NULL);
01281                 <span class="keywordflow">return</span> 0;
01282         }
01283         <span class="keywordflow">return</span> -1;
01284 }
01285 
01286 <span class="keywordtype">int</span>
01287 getftype(m)
01288      <span class="keywordtype">int</span> m;
01289 {
01290         <span class="keywordflow">if</span> ((m&amp;S_IFMT) == S_IFREG)
01291                 <span class="keywordflow">return</span> NFREG;
01292         <span class="keywordflow">if</span> ((m&amp;S_IFMT) == S_IFDIR)
01293                 <span class="keywordflow">return</span> NFDIR;
01294         <span class="keywordflow">if</span> ((m&amp;S_IFMT) == S_IFLNK)
01295                 <span class="keywordflow">return</span> NFLNK;
01296         <span class="keywordflow">if</span> ((m&amp;S_IFMT) == S_IFBLK)
01297                 <span class="keywordflow">return</span> NFBLK;
01298         <span class="keywordflow">if</span> ((m&amp;S_IFMT) == S_IFCHR)
01299                 <span class="keywordflow">return</span> NFCHR;
01300         <span class="keywordflow">if</span> ((m&amp;S_IFMT) == S_IFSOCK)
01301                 <span class="keywordflow">return</span> NFSOCK;
01302         <span class="keywordflow">return</span> NFBAD;
01303 }
01304 
01305 <span class="comment">/* should make . and .. the first entries, but this probably doesn't</span>
01306 <span class="comment">   break anything */</span>
01307 <span class="keyword">struct </span>dirent *
01308 rootrd(cookie)
01309      <span class="keywordtype">long</span> <a class="code" href="cfs__nfs_8c.html#a9">cookie</a>;
01310 {
01311         <span class="keyword">static</span> <span class="keyword">struct </span>dirent <a class="code" href="cfs__cipher_8c.html#a1">d</a>;
01312 
01313         <span class="comment">/* note that cookie should never == NINSTANCES */</span>
01314         <span class="keywordflow">if</span> (<a class="code" href="cfs__nfs_8c.html#a9">cookie</a> == 0) {
01315                 strcpy(<a class="code" href="cfs__cipher_8c.html#a1">d</a>.d_name,<span class="stringliteral">"."</span>);
01316                 <a class="code" href="cfs__cipher_8c.html#a1">d</a>.d_fileno=1;
01317         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="cfs__nfs_8c.html#a9">cookie</a> == 1) {
01318                 strcpy(<a class="code" href="cfs__cipher_8c.html#a1">d</a>.d_name,<span class="stringliteral">".."</span>);
01319                 <a class="code" href="cfs__cipher_8c.html#a1">d</a>.d_fileno=1;
01320         } <span class="keywordflow">else</span> <span class="keywordflow">while</span> (<a class="code" href="cfs__nfs_8c.html#a9">cookie</a>&lt;(<a class="code" href="cfs_8h.html#a5">NINSTANCES</a>+2)) {
01321                 <span class="keywordflow">if</span> (<a class="code" href="cfs_8h.html#a35">instances</a>[<a class="code" href="cfs__nfs_8c.html#a9">cookie</a>-2] != NULL) {
01322                         <span class="keywordflow">if</span> (<a class="code" href="cfs_8h.html#a35">instances</a>[<a class="code" href="cfs__nfs_8c.html#a9">cookie</a>-2]-&gt;anon)
01323                                 sprintf(<a class="code" href="cfs__cipher_8c.html#a1">d</a>.d_name,<span class="stringliteral">".ANON_%d"</span>,cookie-2);
01324                         <span class="keywordflow">else</span>
01325                                 strcpy(<a class="code" href="cfs__cipher_8c.html#a1">d</a>.d_name,
01326                                        instances[cookie-2]-&gt;name);
01327                         <a class="code" href="cfs__cipher_8c.html#a1">d</a>.d_fileno=(0-(<a class="code" href="cfs__nfs_8c.html#a9">cookie</a>-2));
01328                         <span class="keywordflow">break</span>;
01329                 }
01330                 ++<a class="code" href="cfs__nfs_8c.html#a9">cookie</a>;
01331         }
01332         <span class="keywordflow">if</span> (<a class="code" href="cfs__nfs_8c.html#a9">cookie</a>&gt;=(<a class="code" href="cfs_8h.html#a5">NINSTANCES</a>+2))
01333                 <span class="keywordflow">return</span> NULL;
01334         <a class="code" href="cfs__cipher_8c.html#a1">d</a>.d_reclen = ++<a class="code" href="cfs__nfs_8c.html#a9">cookie</a>;
01335         <span class="keywordflow">return</span> &amp;<a class="code" href="cfs__cipher_8c.html#a1">d</a>;
01336 }
01337 
01338 
01339 <span class="keywordtype">int</span>
01340 fhrootlook(n,h)
01341      <span class="keywordtype">char</span> *<a class="code" href="shs_8c.html#a29">n</a>;
<a name="l01342"></a><a class="code" href="cfs__fh_8c.html#a28">01342</a>      nfs_fh *<a class="code" href="cfs__fh_8c.html#a28">h</a>;
01343 {
01344         <span class="keywordtype">int</span> i;
01345         <a class="code" href="structcfs__fileid.html">cfs_fileid</a> *f;
01346         
01347         <span class="keywordflow">if</span> (!strcmp(<a class="code" href="shs_8c.html#a29">n</a>,<span class="stringliteral">"."</span>) || !strcmp(<a class="code" href="shs_8c.html#a29">n</a>,<span class="stringliteral">".."</span>)) {        <span class="comment">/* self */</span>
01348                 bcopy((<span class="keywordtype">char</span> *)&amp;roothandle,(<span class="keywordtype">char</span> *)<a class="code" href="cfs__fh_8c.html#a28">h</a>,<span class="keyword">sizeof</span>(roothandle));
01349                 <span class="keywordflow">return</span> 0;
01350         }
01351         <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="cfs_8h.html#a5">NINSTANCES</a>; i++) {
01352                 <span class="keywordflow">if</span> (<a class="code" href="cfs_8h.html#a35">instances</a>[i]==NULL)
01353                         <span class="keywordflow">continue</span>;
01354                 <span class="keywordflow">if</span> (!strcmp(<a class="code" href="cfs_8h.html#a35">instances</a>[i]-&gt;name,<a class="code" href="shs_8c.html#a29">n</a>)) {
01355                         <span class="keywordflow">if</span> ((f=findh(0,i
01356 #ifdef SHORTLINKS
01357                                         ,0
01358 #endif <span class="comment">/* SHORTLINKS */</span>
01359                                         )) == NULL) {
01360                                 <span class="keywordflow">if</span> ((f=(<a class="code" href="structcfs__fileid.html">cfs_fileid</a> *)
01361                                      malloc(<span class="keyword">sizeof</span>(<a class="code" href="structcfs__fileid.html">cfs_fileid</a>)))==NULL) {
01362                                         fprintf(stderr,<span class="stringliteral">"cfsd: no memory\n"</span>);
01363                                         <a class="code" href="cfs_8h.html#a30">cfserrno</a>=NFSERR_STALE;  <span class="comment">/* bad news */</span>
01364                                         <span class="keywordflow">return</span> -2;
01365                                 }
01366                                 f-&gt;<a class="code" href="structcfs__fileid.html#o0">fileid</a> = 0;
01367                                 f-&gt;<a class="code" href="structcfs__fileid.html#o6">parent</a> = 0;
01368                                 f-&gt;<a class="code" href="structcfs__fileid.html#o8">ins</a>=<a class="code" href="cfs_8h.html#a35">instances</a>[i];
01369                                 inserth(f);
01370                                 <span class="keywordflow">if</span> ((f-&gt;<a class="code" href="structcfs__fileid.html#o4">name</a>=(<span class="keywordtype">char</span> *)
01371                                      malloc(NFS_MAXPATHLEN+1))==NULL) {
01372                                         fprintf(stderr,
01373                                                 <span class="stringliteral">"cfsd: out of memory\n"</span>);
01374                                         <a class="code" href="cfs_8h.html#a30">cfserrno</a>=NFSERR_STALE;
01375                                         <span class="keywordflow">return</span> -2;
01376                                 }
01377                                 strcpy(f-&gt;<a class="code" href="structcfs__fileid.html#o4">name</a>,<a class="code" href="cfs_8h.html#a35">instances</a>[i]-&gt;<a class="code" href="structinstance.html#o1">path</a>);
01378                         }
01379                         fillinh(<a class="code" href="cfs__fh_8c.html#a28">h</a>,i,0,f-&gt;<a class="code" href="structcfs__fileid.html#o8">ins</a>-&gt;<a class="code" href="structinstance.html#o4">check</a>);
01380                         <span class="keywordflow">return</span> 0;
01381                 }
01382         }
01383         <a class="code" href="cfs_8h.html#a30">cfserrno</a>=NFSERR_NOENT;
01384         <span class="keywordflow">return</span> -2;
01385 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Tue Jun 15 09:59:03 2004 for CFS by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>CFS: cfs_nfs.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>cfs_nfs.c</h1><a href="cfs__nfs_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> * The author of this software is Matt Blaze.</span>
00003 <span class="comment"> *              Copyright (c) 1992, 1993, 1994 by AT&amp;T.</span>
00004 <span class="comment"> * Permission to use, copy, and modify this software without fee</span>
00005 <span class="comment"> * is hereby granted, provided that this entire notice is included in</span>
00006 <span class="comment"> * all copies of any software which is or includes a copy or</span>
00007 <span class="comment"> * modification of this software and in all copies of the supporting</span>
00008 <span class="comment"> * documentation for such software.</span>
00009 <span class="comment"> *</span>
00010 <span class="comment"> * This software is subject to United States export controls.</span>
00011 <span class="comment"> *</span>
00012 <span class="comment"> * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR IMPLIED</span>
00013 <span class="comment"> * WARRANTY.  IN PARTICULAR, NEITHER THE AUTHORS NOR AT&amp;T MAKE ANY</span>
00014 <span class="comment"> * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY</span>
00015 <span class="comment"> * OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.</span>
00016 <span class="comment"> */</span>
00017 
00018 <span class="comment">/*</span>
00019 <span class="comment"> * crypto-nfs server functions</span>
00020 <span class="comment"> *  rpc handlers</span>
00021 <span class="comment"> *  access control policies</span>
00022 <span class="comment"> */</span>
00023 
00024 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00025 <span class="preprocessor">#include &lt;sys/file.h&gt;</span>
00026 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00027 <span class="preprocessor">#include &lt;sys/stat.h&gt;</span>
00028 <span class="preprocessor">#include &lt;rpc/rpc.h&gt;</span>
00029 <span class="preprocessor">#include &lt;errno.h&gt;</span>
00030 <span class="preprocessor">#ifdef NeXT</span>
00031 <span class="preprocessor"></span><span class="preprocessor">#include &lt;sys/dir.h&gt;</span>
00032 <span class="preprocessor">#define dirent direct</span>
00033 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00034 <span class="preprocessor"></span><span class="preprocessor">#include &lt;dirent.h&gt;</span>
00035 <span class="preprocessor">#endif</span>
00036 <span class="preprocessor"></span><span class="preprocessor">#include "nfsproto.h"</span>
00037 <span class="preprocessor">#include "admproto.h"</span>
00038 <span class="preprocessor">#include "<a class="code" href="cfs_8h.html">cfs.h</a>"</span>
00039 
<a name="l00040"></a><a class="code" href="cfs__nfs_8c.html#a5">00040</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>svc_req *<a class="code" href="cfs__adm_8c.html#a0">SR</a>;
00041 
<a name="l00042"></a><a class="code" href="cfs__nfs_8c.html#a0">00042</a> <span class="preprocessor">#define herr(x) (((x)==H_INVALID)?NFSERR_STALE:NFSERR_PERM)</span>
00043 <span class="preprocessor"></span>
00044 <span class="keywordtype">char</span> *
00045 <a class="code" href="cfs__nfs_8c.html#a11">pfh</a>(fh)
00046      <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *fh;
00047 {
00048         <span class="keyword">static</span> <span class="keywordtype">char</span> ret[NFS_FHSIZE*2+2];
00049         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> x[3];
00050         <span class="keywordtype">int</span> i;
00051 
00052         ret[0]=<span class="charliteral">'\0'</span>;
00053         <span class="keywordflow">for</span> (i=0; i&lt;NFS_FHSIZE; i++) {
00054                 sprintf((<span class="keywordtype">char</span> *)x,<span class="stringliteral">"%02x"</span>,fh[i]);
00055                 strcat(ret,x);
00056         }
00057         <span class="keywordflow">return</span> ret;
00058 }
00059 
00060 <span class="keywordtype">void</span> *
00061 nfsproc_null_2(ap,rp)
00062      <span class="keywordtype">void</span> *ap;
00063      <a class="code" href="cfs__adm_8c.html#a0">SR</a> <a class="code" href="cfs__nfs_8c.html#a2">rp</a>;
00064 {
00065         <span class="keyword">static</span> <span class="keywordtype">int</span> ret=0;
00066         <span class="keywordflow">return</span> ((<span class="keywordtype">void</span>*) &amp;ret);
00067 }
00068 
00069 <span class="preprocessor">#define as_attr attrstat_u.attributes</span>
00070 <span class="preprocessor"></span>
00071 diropres *rootlookup();
00072 readdirres *<a class="code" href="cfs__nfs_8c.html#a12">rootreaddir</a>();
00073 
00074 attrstat *
00075 <a class="code" href="cfs__nfs_8c.html#a13">nfsproc_getattr_2</a>(ap,rp)
00076      nfs_fh *ap;
00077      <a class="code" href="cfs__adm_8c.html#a0">SR</a> <a class="code" href="cfs__nfs_8c.html#a2">rp</a>;
00078 {
00079         <span class="keyword">static</span> attrstat ret;
00080         <span class="keywordtype">int</span> <a class="code" href="cfs__fh_8c.html#a20">uid</a>;
00081         <span class="keywordtype">int</span> ht;
00082         <a class="code" href="structcfs__fileid.html">cfs_fileid</a> *<a class="code" href="cfs__fh_8c.html#a28">h</a>;
00083 
00084 <span class="preprocessor">#ifdef DEBUG</span>
00085 <span class="preprocessor"></span>        printf(<span class="stringliteral">"getattr:\n"</span>);
00086 <span class="preprocessor">#endif</span>
00087 <span class="preprocessor"></span>        <span class="keywordflow">if</span> ((ht=htype(h=<a class="code" href="cfs_8h.html#a41">geth</a>(ap)))!=<a class="code" href="cfs_8h.html#a0">H_REG</a>) {
00088                 <span class="comment">/* this is an ugly hack to deal w/ lookups in root,</span>
00089 <span class="comment">                   but it will do for now */</span>;
00090                 <span class="keywordflow">if</span> (ht==<a class="code" href="cfs_8h.html#a2">H_ROOT</a>) {
00091                         ret.status=NFS_OK;
00092                         rootgetattr(&amp;ret.as_attr);
00093                         <span class="keywordflow">return</span> &amp;ret;
00094                 }
00095                 ret.status=NFSERR_STALE;
00096                 <span class="keywordflow">return</span> &amp;ret;
00097         }
00098         <a class="code" href="cfs__fh_8c.html#a20">uid</a>=ruid(rp);
00099         <span class="keywordflow">if</span> (!fhuid(h,uid)) {
00100                 ret.status = NFSERR_PERM;
00101                 <span class="keywordflow">return</span> &amp;ret;
00102         }
00103         <a class="code" href="cfs_8h.html#a21">become</a>(rp);     <span class="comment">/* become the user */</span>
00104         <span class="keywordflow">switch</span> (fhstat(h,&amp;ret.as_attr)) {
00105             <span class="keywordflow">case</span> 0:     <span class="comment">/* ok */</span>
00106                 ret.status=NFS_OK;
00107                 <span class="keywordflow">break</span>;
00108             <span class="keywordflow">case</span> -1:    <span class="comment">/* error from syscall */</span>
00109                 ret.status=cfsno(errno);
00110                 <span class="keywordflow">break</span>;
00111             <span class="keywordflow">default</span>:    <span class="comment">/* bad handle, probably */</span>
00112                 ret.status=<a class="code" href="cfs_8h.html#a30">cfserrno</a>;
00113                 <span class="keywordflow">break</span>;
00114         }
00115         closeout(h);    <span class="comment">/* if it was open, close it */</span>
00116         <a class="code" href="cfs_8h.html#a21">become</a>(NULL);
00117         <span class="keywordflow">return</span> &amp;ret;
00118 }
00119 
00120 attrstat *
00121 nfsproc_setattr_2(ap,rp)
00122      sattrargs *ap;
00123      <a class="code" href="cfs__adm_8c.html#a0">SR</a> <a class="code" href="cfs__nfs_8c.html#a2">rp</a>;
00124 {
00125         <span class="keyword">static</span> attrstat ret;
00126         <span class="keywordtype">int</span> <a class="code" href="cfs__fh_8c.html#a20">uid</a>;
00127         <span class="keywordtype">int</span> ht;
00128         <a class="code" href="structcfs__fileid.html">cfs_fileid</a> *<a class="code" href="cfs__fh_8c.html#a28">h</a>;
00129 
00130         <span class="comment">/* this is non-atomic, and could leave partial results */</span>
00131         <span class="comment">/* also, we vary from std nfs semantics in that failure does</span>
00132 <span class="comment">           not always leave the file in its previous state */</span>
00133 
00134 <span class="preprocessor">#ifdef DEBUG</span>
00135 <span class="preprocessor"></span>        printf(<span class="stringliteral">"setattr: \n"</span>);
00136 <span class="preprocessor">#endif</span>
00137 <span class="preprocessor"></span>        <span class="keywordflow">if</span> ((ht=htype(h=<a class="code" href="cfs_8h.html#a41">geth</a>(&amp;ap-&gt;file)))!=<a class="code" href="cfs_8h.html#a0">H_REG</a>) {
00138                 ret.status=<a class="code" href="cfs__nfs_8c.html#a0">herr</a>(ht);
00139                 <span class="keywordflow">return</span> &amp;ret;
00140         }
00141         <a class="code" href="cfs__fh_8c.html#a20">uid</a>=ruid(rp);
00142         <a class="code" href="cfs_8h.html#a21">become</a>(rp);     <span class="comment">/* become the user */</span>
00143         <span class="keywordflow">switch</span> (fhsetattr(h,&amp;ap-&gt;attributes)) {
00144             <span class="keywordflow">case</span> 0:     <span class="comment">/* ok */</span>
00145                 <span class="comment">/* now do a getattr */</span>          
00146                 <span class="keywordflow">switch</span> (fhstat(h,&amp;ret.as_attr)) {
00147                     <span class="keywordflow">case</span> 0:
00148                         ret.status=NFS_OK;
00149                         <span class="keywordflow">break</span>;
00150                     <span class="keywordflow">case</span> -1:
00151                         ret.status=cfsno(errno);
00152                         <span class="keywordflow">break</span>;
00153                     <span class="keywordflow">default</span>:
00154                         ret.status=<a class="code" href="cfs_8h.html#a30">cfserrno</a>;
00155                         <span class="keywordflow">break</span>;
00156                 }
00157                 <span class="keywordflow">break</span>;
00158             <span class="keywordflow">case</span> -1:    <span class="comment">/* error from syscall */</span>
00159                 <span class="comment">/* but some things may be already set.  should fix this */</span>
00160                 ret.status=cfsno(errno);
00161                 <span class="keywordflow">break</span>;
00162             <span class="keywordflow">default</span>:    <span class="comment">/* bad handle, probably */</span>
00163                 ret.status=<a class="code" href="cfs_8h.html#a30">cfserrno</a>;
00164                 <span class="keywordflow">break</span>;
00165         }
00166         <a class="code" href="cfs_8h.html#a21">become</a>(NULL);
00167         <span class="keywordflow">return</span> &amp;ret;
00168 }
00169 
00170 <span class="keywordtype">void</span> *
00171 nfsproc_root_2(ap,rp)
00172      <span class="keywordtype">void</span> *ap;
00173      <a class="code" href="cfs__adm_8c.html#a0">SR</a> <a class="code" href="cfs__nfs_8c.html#a2">rp</a>;
00174 {
00175         <span class="keyword">static</span> <span class="keywordtype">int</span> ret=0;
00176 
00177         <span class="keywordflow">return</span> ((<span class="keywordtype">void</span>*)&amp;ret);
00178 }
00179 
00180 <span class="comment">/* fix this to deal w/ fs root (instance root should be ok) */</span>
00181 diropres *
00182 nfsproc_lookup_2(ap,rp)
00183      diropargs *ap;
00184      <a class="code" href="cfs__adm_8c.html#a0">SR</a> <a class="code" href="cfs__nfs_8c.html#a2">rp</a>;
00185 {
00186         <span class="keyword">static</span> diropres ret;
00187         diropres *retp;
00188         nfs_fh *handle;
00189         <span class="keywordtype">int</span> <a class="code" href="cfs__fh_8c.html#a20">uid</a>;
00190         <a class="code" href="structcfskey.html">cfskey</a> *<a class="code" href="mcg_8c.html#a0">key</a>;
00191         <span class="keywordtype">char</span> *<a class="code" href="cfs__fh_8c.html#a0">s</a>;
00192         <span class="keywordtype">int</span> ht;
00193         <a class="code" href="structcfs__fileid.html">cfs_fileid</a> *<a class="code" href="cfs__fh_8c.html#a28">h</a>;
00194 
00195         <span class="comment">/* this, mkdir, create, and the mount protocol are the only ways</span>
00196 <span class="comment">           to create a handle */</span>
00197 <span class="preprocessor">#ifdef DEBUG</span>
00198 <span class="preprocessor"></span>        printf(<span class="stringliteral">"lookup: \n"</span>);
00199 <span class="preprocessor">#endif</span>
00200 <span class="preprocessor"></span>        <span class="comment">/* this is where most of the security has to lie, since lookup</span>
00201 <span class="comment">           returns handles to files.  so we have to make sure we're coming</span>
00202 <span class="comment">           from the right place and that it's really a priv port, etc */</span>
00203         <span class="keywordflow">if</span> (!<a class="code" href="cfs__nfs_8c.html#a15">goodsrc</a>(rp)) {
00204                 ret.status=NFSERR_PERM;
00205                 <span class="keywordflow">return</span> &amp;ret;
00206         }
00207         <span class="keywordflow">if</span> ((ht=htype(h=<a class="code" href="cfs_8h.html#a41">geth</a>(&amp;ap-&gt;dir)))!=<a class="code" href="cfs_8h.html#a0">H_REG</a>) {
00208                 <span class="keywordflow">if</span> (ht==<a class="code" href="cfs_8h.html#a2">H_ROOT</a>) {
00209                         <a class="code" href="cfs_8h.html#a21">become</a>(rp);
00210                         retp=rootlookup(ap-&gt;name);
00211                         <a class="code" href="cfs_8h.html#a21">become</a>(NULL);
00212                         <span class="keywordflow">return</span> retp;
00213                 }
00214                 ret.status=<a class="code" href="cfs__nfs_8c.html#a0">herr</a>(ht);
00215                 <span class="keywordflow">return</span> &amp;ret;
00216         }
00217         <a class="code" href="cfs__fh_8c.html#a20">uid</a>=ruid(rp);
00218         <span class="keywordflow">if</span> (!fhuid(h,uid)) {
00219                 ret.status = NFSERR_PERM;
00220                 <span class="keywordflow">return</span> &amp;ret;
00221         }
00222 
00223         <a class="code" href="cfs_8h.html#a21">become</a>(rp);     <span class="comment">/* become the user */</span>
00224         handle = &amp;ret.diropres_u.diropres.file;
00225         <a class="code" href="mcg_8c.html#a0">key</a>=<a class="code" href="cfs_8h.html#a22">keyof</a>(h);
00226         <span class="keywordflow">if</span> (<a class="code" href="mcg_8c.html#a0">key</a>==NULL)
00227                 ret.status=cfsno(errno);
00228         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((<a class="code" href="cfs__fh_8c.html#a0">s</a>=<a class="code" href="cfs_8h.html#a39">encryptname</a>(key,ap-&gt;name))==NULL)
00229                 ret.status=NFSERR_NOENT;
00230         <span class="keywordflow">else</span> <span class="keywordflow">switch</span> (fhlook(h,s,handle)) {
00231             <span class="comment">/* fhlook might update the underlying name associated with the</span>
00232 <span class="comment">               handle, or delete the handle */</span>
00233             <span class="keywordflow">case</span> 0:     <span class="comment">/* found it */</span>
00234                 <span class="comment">/* now do a getattr */</span>          
00235                 <span class="keywordflow">switch</span> (fhstat(<a class="code" href="cfs_8h.html#a41">geth</a>(handle),
00236                                &amp;ret.diropres_u.diropres.attributes)) {
00237                     <span class="keywordflow">case</span> 0:
00238                         ret.status=NFS_OK;
00239                         <span class="comment">/* stat is already in attributes field */</span>
00240                         <span class="keywordflow">break</span>;
00241                     <span class="keywordflow">case</span> -1:    <span class="comment">/* couldn't open file for some reason */</span>
00242                         ret.status=cfsno(errno);
00243                         <span class="keywordflow">break</span>;
00244                     <span class="keywordflow">default</span>:    <span class="comment">/* shouldn't happen */</span>
00245                         ret.status=<a class="code" href="cfs_8h.html#a30">cfserrno</a>;
00246                         <span class="keywordflow">break</span>;
00247                 }
00248                 <span class="keywordflow">break</span>;
00249             <span class="keywordflow">case</span> -1:    <span class="comment">/* some parent dir went away, probably */</span>
00250                 ret.status=cfsno(errno);
00251                 <span class="keywordflow">break</span>;
00252             <span class="keywordflow">default</span>:    <span class="comment">/* bad parent handle or notfound, probably */</span>
00253                 ret.status=<a class="code" href="cfs_8h.html#a30">cfserrno</a>;
00254                 <span class="keywordflow">break</span>;
00255         }
00256         <a class="code" href="cfs_8h.html#a21">become</a>(NULL);
00257         <span class="keywordflow">return</span> (&amp;ret);
00258 }
00259 
00260 readlinkres *
00261 nfsproc_readlink_2(ap,rp)
00262      nfs_fh *ap;
00263      <a class="code" href="cfs__adm_8c.html#a0">SR</a> <a class="code" href="cfs__nfs_8c.html#a2">rp</a>;
00264 {
00265         <span class="keyword">static</span> readlinkres ret;
00266         <span class="keywordtype">int</span> <a class="code" href="cfs__fh_8c.html#a20">uid</a>;
00267         <span class="keywordtype">char</span> <a class="code" href="cfs__fh_8c.html#a34">buf</a>[NFS_MAXPATHLEN+1];
00268         <span class="keywordtype">char</span> *<a class="code" href="cfs__fh_8c.html#a0">s</a>;
00269         <a class="code" href="structcfskey.html">cfskey</a> *<a class="code" href="mcg_8c.html#a0">key</a>;
00270         <span class="keywordtype">int</span> ht;
00271         <a class="code" href="structcfs__fileid.html">cfs_fileid</a> *<a class="code" href="cfs__fh_8c.html#a28">h</a>;
00272         <span class="keywordtype">int</span> <a class="code" href="cfs__fh_8c.html#a14">l</a>;
00273 
00274 <span class="preprocessor">#ifdef DEBUG</span>
00275 <span class="preprocessor"></span>        printf(<span class="stringliteral">"readlink:\n"</span>);
00276 <span class="preprocessor">#endif</span>
00277 <span class="preprocessor"></span>        <span class="keywordflow">if</span> ((ht=htype(h=<a class="code" href="cfs_8h.html#a41">geth</a>(ap)))!=<a class="code" href="cfs_8h.html#a0">H_REG</a>) {
00278                 ret.status=<a class="code" href="cfs__nfs_8c.html#a0">herr</a>(ht);
00279                 <span class="keywordflow">return</span> &amp;ret;
00280         }
00281         <a class="code" href="cfs__fh_8c.html#a20">uid</a>=ruid(rp);
00282         <a class="code" href="cfs_8h.html#a21">become</a>(rp);
00283 
00284         <span class="keywordflow">switch</span> (<a class="code" href="cfs__fh_8c.html#a14">l</a>=fhlinkval(h,buf)) {
00285             <span class="keywordflow">case</span> -1:
00286                 ret.status=cfsno(errno);
00287                 <span class="keywordflow">break</span>;
00288             <span class="keywordflow">case</span> -2:
00289                 ret.status=<a class="code" href="cfs_8h.html#a30">cfserrno</a>;
00290                 <span class="keywordflow">break</span>;
00291             <span class="keywordflow">default</span>:
00292                 <a class="code" href="cfs__fh_8c.html#a34">buf</a>[<a class="code" href="cfs__fh_8c.html#a14">l</a>]=<span class="charliteral">'\0'</span>;
00293                 <span class="keywordflow">if</span> ((<a class="code" href="mcg_8c.html#a0">key</a>=<a class="code" href="cfs_8h.html#a22">keyof</a>(h))==NULL) {
00294                         ret.status=<a class="code" href="cfs_8h.html#a30">cfserrno</a>;
00295                         <span class="keywordflow">break</span>;
00296                 }
00297                 <span class="keywordflow">if</span> ((<a class="code" href="cfs__fh_8c.html#a0">s</a>=<a class="code" href="cfs_8h.html#a40">decryptname</a>(key,buf)) == NULL) {
00298                         ret.status=NFSERR_NOENT; <span class="comment">/* close enough */</span>
00299                         <span class="keywordflow">break</span>;
00300                 }
00301                 ret.readlinkres_u.data = <a class="code" href="cfs__fh_8c.html#a0">s</a>;
00302                 ret.status=NFS_OK;
00303                 <span class="keywordflow">break</span>;
00304         }
00305 
00306         <a class="code" href="cfs_8h.html#a21">become</a>(NULL);
00307         <span class="keywordflow">return</span> (&amp;ret);
00308 }
00309 
00310 
00311 readres *
00312 nfsproc_read_2(ap,rp)
00313      readargs *ap;
00314      <a class="code" href="cfs__adm_8c.html#a0">SR</a> <a class="code" href="cfs__nfs_8c.html#a2">rp</a>;
00315 {
00316         <span class="keyword">static</span> readres ret;
00317         <span class="keyword">static</span> <span class="keywordtype">char</span> buffer[8192];
00318         <span class="keywordtype">int</span> <a class="code" href="cfs__fh_8c.html#a8">fd</a>;
00319         <span class="keywordtype">int</span> <a class="code" href="cfs__fh_8c.html#a20">uid</a>;
00320         <span class="keywordtype">int</span> <a class="code" href="cfs__fh_8c.html#a0">len</a>;
00321         <a class="code" href="structcfskey.html">cfskey</a> *<a class="code" href="mcg_8c.html#a0">key</a>;
00322         <span class="keywordtype">int</span> ht;
00323         <a class="code" href="structcfs__fileid.html">cfs_fileid</a> *<a class="code" href="cfs__fh_8c.html#a28">h</a>;
00324         
00325 <span class="preprocessor">#ifdef DEBUG</span>
00326 <span class="preprocessor"></span>        printf(<span class="stringliteral">"read:\n"</span>);
00327 <span class="preprocessor">#endif</span>
00328 <span class="preprocessor"></span>        <span class="keywordflow">if</span> ((ht=htype(h=<a class="code" href="cfs_8h.html#a41">geth</a>(&amp;ap-&gt;file)))!=<a class="code" href="cfs_8h.html#a0">H_REG</a>) {
00329                 ret.status=<a class="code" href="cfs__nfs_8c.html#a0">herr</a>(ht);
00330                 <span class="keywordflow">return</span> &amp;ret;
00331         }
00332         <a class="code" href="cfs__fh_8c.html#a20">uid</a>=ruid(rp);
00333         <span class="keywordflow">if</span> (!fhuid(h,uid)) {
00334                 ret.status = NFSERR_PERM;
00335                 <span class="keywordflow">return</span> &amp;ret;
00336         }
00337         <a class="code" href="cfs_8h.html#a21">become</a>(rp);
00338         <span class="keywordflow">switch</span> (<a class="code" href="cfs__fh_8c.html#a8">fd</a>=<a class="code" href="cfs__fh_8c.html#a40">fhtofd</a>(h,CFS_READ)) {
00339             <span class="keywordflow">case</span> -1:    <span class="comment">/* syscall error */</span>
00340                 ret.status = cfsno(errno);
00341                 <span class="keywordflow">break</span>;
00342             <span class="keywordflow">case</span> -2:    <span class="comment">/* cfs error */</span>
00343                 ret.status = <a class="code" href="cfs_8h.html#a30">cfserrno</a>;
00344                 <span class="keywordflow">break</span>;
00345             <span class="keywordflow">default</span>:    <span class="comment">/* fd should be valid file descriptor */</span>
00346                 <span class="comment">/* do the read */</span>
00347                 <a class="code" href="mcg_8c.html#a0">key</a>=<a class="code" href="cfs_8h.html#a22">keyof</a>(h);
00348                 <span class="keywordflow">if</span> (<a class="code" href="mcg_8c.html#a0">key</a>==NULL) {
00349                         ret.status=<a class="code" href="cfs_8h.html#a30">cfserrno</a>;
00350                         <span class="keywordflow">break</span>;
00351                 }                       
00352                 <span class="keywordflow">if</span> ((<a class="code" href="cfs__fh_8c.html#a0">len</a>=<a class="code" href="cfs__fh_8c.html#a38">readblock</a>(buffer,fd,ap-&gt;offset,ap-&gt;count,
00353                                    key,<a class="code" href="cfs_8h.html#a23">vectof</a>(h)))&lt;0){
00354                         ret.status = cfsno(errno);
00355                         <span class="keywordflow">break</span>;
00356                 }
00357                 <span class="keywordflow">if</span> (fhstat(h,&amp;ret.readres_u.reply.attributes)!=0) {
00358                         ret.status = cfsno(errno);
00359                         <span class="keywordflow">break</span>;
00360                 }
00361                 ret.readres_u.reply.data.data_len = 
00362                         (<a class="code" href="cfs__fh_8c.html#a0">len</a> &gt; (ap-&gt;count)) ? ap-&gt;count : <a class="code" href="cfs__fh_8c.html#a0">len</a>;
00363                 ret.readres_u.reply.data.data_val = buffer;
00364                 ret.status = NFS_OK;
00365                 <span class="keywordflow">break</span>;
00366         }
00367         <a class="code" href="cfs_8h.html#a21">become</a>(NULL);
00368         <span class="keywordflow">return</span> (&amp;ret);
00369 }
00370 
00371 
00372 <span class="keywordtype">void</span> *
00373 nfsproc_writecache_2(ap,rp)
00374      <span class="keywordtype">void</span> *ap;
00375      <a class="code" href="cfs__adm_8c.html#a0">SR</a> <a class="code" href="cfs__nfs_8c.html#a2">rp</a>;
00376 {
00377         <span class="keyword">static</span> <span class="keywordtype">int</span> ret;
00378 
00379         <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *)(&amp;ret);
00380 }
00381 
00382 
00383 attrstat *
00384 nfsproc_write_2(ap,rp)
00385      writeargs *ap;
00386      <a class="code" href="cfs__adm_8c.html#a0">SR</a> <a class="code" href="cfs__nfs_8c.html#a2">rp</a>;
00387 {
00388         <span class="keyword">static</span> attrstat ret;
00389         <span class="keywordtype">int</span> <a class="code" href="cfs__fh_8c.html#a8">fd</a>;
00390         <span class="keywordtype">int</span> <a class="code" href="cfs__fh_8c.html#a20">uid</a>;
00391         <span class="keywordtype">int</span> <a class="code" href="cfs__fh_8c.html#a0">len</a>;
00392         <span class="keywordtype">int</span> <a class="code" href="cfs__fh_8c.html#a9">offset</a>;
00393         <a class="code" href="structcfskey.html">cfskey</a> *<a class="code" href="mcg_8c.html#a0">key</a>;
00394         <span class="keywordtype">char</span> *<a class="code" href="cfs__fh_8c.html#a34">buf</a>;
00395         <span class="keywordtype">int</span> ht;
00396         <a class="code" href="structcfs__fileid.html">cfs_fileid</a> *<a class="code" href="cfs__fh_8c.html#a28">h</a>;
00397 
00398 <span class="preprocessor">#ifdef DEBUG</span>
00399 <span class="preprocessor"></span>        printf(<span class="stringliteral">"write:\n"</span>);
00400 <span class="preprocessor">#endif</span>
00401 <span class="preprocessor"></span>        <span class="keywordflow">if</span> ((ht=htype(h=<a class="code" href="cfs_8h.html#a41">geth</a>(&amp;ap-&gt;file)))!=<a class="code" href="cfs_8h.html#a0">H_REG</a>) {
00402                 ret.status=<a class="code" href="cfs__nfs_8c.html#a0">herr</a>(ht);
00403                 <span class="keywordflow">return</span> &amp;ret;
00404         }
00405 
00406         <a class="code" href="cfs__fh_8c.html#a20">uid</a>=ruid(rp);
00407         <span class="keywordflow">if</span> (!fhuid(h,uid)) {
00408                 ret.status = NFSERR_PERM;
00409                 <span class="keywordflow">return</span> &amp;ret;
00410         }
00411         <a class="code" href="cfs_8h.html#a21">become</a>(rp);
00412         <span class="keywordflow">switch</span> (<a class="code" href="cfs__fh_8c.html#a8">fd</a>=<a class="code" href="cfs__fh_8c.html#a40">fhtofd</a>(h,CFS_WRITE)) {
00413             <span class="keywordflow">case</span> -1:    <span class="comment">/* syscall error */</span>
00414                 ret.status = cfsno(errno);
00415                 <span class="keywordflow">break</span>;
00416             <span class="keywordflow">case</span> -2:    <span class="comment">/* cfs error */</span>
00417                 ret.status = <a class="code" href="cfs_8h.html#a30">cfserrno</a>;
00418                 <span class="keywordflow">break</span>;
00419             <span class="keywordflow">default</span>:    <span class="comment">/* fd should be valid file descriptor */</span>
00420                 <a class="code" href="cfs__fh_8c.html#a0">len</a> = ap-&gt;data.data_len;
00421                 <a class="code" href="cfs__fh_8c.html#a9">offset</a> = ap-&gt;offset;
00422                 <a class="code" href="cfs__fh_8c.html#a34">buf</a> = ap-&gt;data.data_val;
00423                 <a class="code" href="mcg_8c.html#a0">key</a>=<a class="code" href="cfs_8h.html#a22">keyof</a>(h);
00424                 <span class="keywordflow">if</span> (<a class="code" href="mcg_8c.html#a0">key</a>==NULL) {
00425                         ret.status=<a class="code" href="cfs_8h.html#a30">cfserrno</a>;
00426                         <span class="keywordflow">break</span>;
00427                 }
00428                 <span class="keywordflow">if</span> (writeblock(buf,fd,offset,len,key,<a class="code" href="cfs_8h.html#a23">vectof</a>(h)) &lt; 0) {
00429                         ret.status = cfsno(errno);
00430                         <span class="keywordflow">break</span>;
00431                 }
00432                 <span class="keywordflow">if</span> (fhstat(h,&amp;ret.attrstat_u.attributes)!=0) {
00433                         ret.status = cfsno(errno);
00434                         <span class="keywordflow">break</span>;
00435                 }
00436                 ret.status = NFS_OK;
00437                 <span class="keywordflow">break</span>;
00438         }
00439         <a class="code" href="cfs_8h.html#a21">become</a>(NULL);
00440         <span class="keywordflow">return</span> (&amp;ret);
00441 }
00442 
00443 
00444 diropres *
00445 nfsproc_create_2(ap,rp)
00446      createargs *ap;
00447      <a class="code" href="cfs__adm_8c.html#a0">SR</a> <a class="code" href="cfs__nfs_8c.html#a2">rp</a>;
00448 {
00449         <span class="keyword">static</span> diropres ret;
00450         <span class="keyword">static</span> nfs_fh handle;
00451         <span class="keywordtype">int</span> <a class="code" href="cfs__fh_8c.html#a20">uid</a>;
00452         <span class="keywordtype">int</span> ht;
00453         <span class="keywordtype">char</span> *<a class="code" href="cfs__fh_8c.html#a0">s</a>;
00454         <a class="code" href="structcfs__fileid.html">cfs_fileid</a> *<a class="code" href="cfs__fh_8c.html#a28">h</a>, *h2;
00455 
00456 <span class="preprocessor">#ifdef DEBUG</span>
00457 <span class="preprocessor"></span>        printf(<span class="stringliteral">"create:\n"</span>);
00458 <span class="preprocessor">#endif</span>
00459 <span class="preprocessor"></span>        <span class="comment">/* this, lookup, mkdir, and the mount protocol are the only ways</span>
00460 <span class="comment">           to create a handle */</span>
00461         <span class="keywordflow">if</span> (!<a class="code" href="cfs__nfs_8c.html#a15">goodsrc</a>(rp)) {
00462                 ret.status=NFSERR_PERM;
00463                 <span class="keywordflow">return</span> &amp;ret;
00464         }
00465         <span class="keywordflow">if</span> ((ht=htype(h=<a class="code" href="cfs_8h.html#a41">geth</a>(&amp;ap-&gt;where.dir)))!=<a class="code" href="cfs_8h.html#a0">H_REG</a>) {
00466                 ret.status=<a class="code" href="cfs__nfs_8c.html#a0">herr</a>(ht);
00467                 <span class="keywordflow">return</span> &amp;ret;
00468         }
00469         <a class="code" href="cfs__fh_8c.html#a20">uid</a>=ruid(rp);
00470         <span class="keywordflow">if</span> (!fhuid(h,uid)) {
00471                 ret.status = NFSERR_PERM;
00472                 <span class="keywordflow">return</span> &amp;ret;
00473         }
00474         <a class="code" href="cfs_8h.html#a21">become</a>(rp);
00475         
00476         <span class="comment">/* first create the dir entry */</span>
00477         <span class="comment">/* if one already exist, the underlying handle name field gets</span>
00478 <span class="comment">           updated to reflect its new name */</span>
00479         <a class="code" href="cfs__fh_8c.html#a0">s</a>=<a class="code" href="cfs_8h.html#a39">encryptname</a>(<a class="code" href="cfs_8h.html#a22">keyof</a>(h),ap-&gt;where.name);
00480         <span class="keywordflow">switch</span> (fhmkfileent(h,s,&amp;handle)) {
00481             <span class="keywordflow">case</span> 0: <span class="comment">/* didnt exist */</span>
00482                 <span class="keywordflow">switch</span> (fhsetattr(h2=<a class="code" href="cfs_8h.html#a41">geth</a>(&amp;handle),&amp;ap-&gt;attributes)) {
00483                     <span class="keywordflow">case</span> 0:     <span class="comment">/* ok */</span>
00484                         <span class="comment">/* now do a getattr */</span>          
00485                         <span class="keywordflow">switch</span> (fhstat(h2,
00486                                        &amp;ret.diropres_u.diropres.attributes)) {
00487                             <span class="keywordflow">case</span> 0:
00488                                 bcopy(&amp;handle,&amp;ret.diropres_u.diropres.file,
00489                                       <span class="keyword">sizeof</span>(nfs_fh));
00490                                 ret.status=NFS_OK;
00491                                 <span class="keywordflow">break</span>;
00492                             <span class="keywordflow">case</span> -1:
00493                                 ret.status=cfsno(errno);
00494                                 <span class="keywordflow">break</span>;
00495                             <span class="keywordflow">default</span>:
00496                                 ret.status=<a class="code" href="cfs_8h.html#a30">cfserrno</a>;
00497                                 <span class="keywordflow">break</span>;
00498                         }
00499                         <span class="keywordflow">break</span>;
00500                     <span class="keywordflow">case</span> -1:    <span class="comment">/* error from syscall */</span>
00501                         ret.status=cfsno(errno);
00502                         <span class="keywordflow">break</span>;
00503                     <span class="keywordflow">default</span>:    <span class="comment">/* bad handle, probably */</span>
00504                         ret.status=<a class="code" href="cfs_8h.html#a30">cfserrno</a>;
00505                         <span class="keywordflow">break</span>;
00506                 }
00507                 <span class="keywordflow">break</span>;
00508             <span class="keywordflow">case</span> 1:     <span class="comment">/* did exist; no chmod - KLUDGE */</span>
00509                 <span class="keywordflow">switch</span> (fhsetattrprime(h2=<a class="code" href="cfs_8h.html#a41">geth</a>(&amp;handle),&amp;ap-&gt;attributes)) {
00510                     <span class="keywordflow">case</span> 0:     <span class="comment">/* ok */</span>
00511                         <span class="comment">/* now do a getattr */</span>          
00512                         <span class="keywordflow">switch</span> (fhstat(h2,
00513                                        &amp;ret.diropres_u.diropres.attributes)) {
00514                             <span class="keywordflow">case</span> 0:
00515                                 bcopy(&amp;handle,&amp;ret.diropres_u.diropres.file,
00516                                       <span class="keyword">sizeof</span>(nfs_fh));
00517                                 ret.status=NFS_OK;
00518                                 <span class="keywordflow">break</span>;
00519                             <span class="keywordflow">case</span> -1:
00520                                 ret.status=cfsno(errno);
00521                                 <span class="keywordflow">break</span>;
00522                             <span class="keywordflow">default</span>:
00523                                 ret.status=<a class="code" href="cfs_8h.html#a30">cfserrno</a>;
00524                                 <span class="keywordflow">break</span>;
00525                         }
00526                         <span class="keywordflow">break</span>;
00527                     <span class="keywordflow">case</span> -1:    <span class="comment">/* error from syscall */</span>
00528                         ret.status=cfsno(errno);
00529                         <span class="keywordflow">break</span>;
00530                     <span class="keywordflow">default</span>:    <span class="comment">/* bad handle, probably */</span>
00531                         ret.status=<a class="code" href="cfs_8h.html#a30">cfserrno</a>;
00532                         <span class="keywordflow">break</span>;
00533                 }
00534                 <span class="keywordflow">break</span>;
00535             <span class="keywordflow">case</span> -1:
00536                 ret.status=cfsno(errno);
00537                 <span class="keywordflow">break</span>;
00538             <span class="keywordflow">default</span>:
00539                 ret.status=<a class="code" href="cfs_8h.html#a30">cfserrno</a>;
00540                 <span class="keywordflow">break</span>;
00541         }
00542         <a class="code" href="cfs_8h.html#a21">become</a>(NULL);
00543         <span class="keywordflow">return</span> (&amp;ret);
00544 }
00545 
00546 
00547 nfsstat *
00548 nfsproc_remove_2(ap,rp)
00549      diropargs *ap;
00550      <a class="code" href="cfs__adm_8c.html#a0">SR</a> <a class="code" href="cfs__nfs_8c.html#a2">rp</a>;
00551 {
00552         <span class="keyword">static</span> nfsstat ret;
00553         <span class="keywordtype">char</span> *<a class="code" href="cfs__fh_8c.html#a0">s</a>;
00554         <a class="code" href="structcfskey.html">cfskey</a> *<a class="code" href="mcg_8c.html#a0">key</a>;
00555         <span class="keywordtype">int</span> <a class="code" href="cfs__fh_8c.html#a20">uid</a>;
00556         <span class="keywordtype">int</span> ht;
00557         <a class="code" href="structcfs__fileid.html">cfs_fileid</a> *<a class="code" href="cfs__fh_8c.html#a28">h</a>;
00558 
00559 <span class="preprocessor">#ifdef DEBUG</span>
00560 <span class="preprocessor"></span>        printf(<span class="stringliteral">"remove:\n"</span>);
00561 <span class="preprocessor">#endif</span>
00562 <span class="preprocessor"></span>        <span class="keywordflow">if</span> ((ht=htype(h=<a class="code" href="cfs_8h.html#a41">geth</a>(&amp;ap-&gt;dir)))!=<a class="code" href="cfs_8h.html#a0">H_REG</a>) {
00563                 ret=<a class="code" href="cfs__nfs_8c.html#a0">herr</a>(ht);
00564                 <span class="keywordflow">return</span> &amp;ret;
00565         }
00566         <a class="code" href="cfs__fh_8c.html#a20">uid</a>=ruid(rp);
00567         <a class="code" href="cfs_8h.html#a21">become</a>(rp);     <span class="comment">/* become the user */</span>
00568         <span class="comment">/* first encrypt the name */</span>
00569         <a class="code" href="mcg_8c.html#a0">key</a>=<a class="code" href="cfs_8h.html#a22">keyof</a>(h);
00570         <span class="keywordflow">if</span> (<a class="code" href="mcg_8c.html#a0">key</a>==NULL) {
00571                 ret=<a class="code" href="cfs_8h.html#a30">cfserrno</a>;
00572         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((<a class="code" href="cfs__fh_8c.html#a0">s</a>=<a class="code" href="cfs_8h.html#a39">encryptname</a>(key,ap-&gt;name)) == NULL) {
00573                 ret=NFSERR_NOENT; <span class="comment">/* close enough */</span>
00574         } <span class="keywordflow">else</span> <span class="keywordflow">switch</span> (fhdelete(h,s)) {
00575             <span class="keywordflow">case</span> 0:
00576                 ret=NFS_OK;
00577                 <span class="keywordflow">break</span>;
00578             <span class="keywordflow">case</span> -1:
00579                 ret=cfsno(errno);
00580                 <span class="keywordflow">break</span>;
00581             <span class="keywordflow">default</span>:
00582                 ret=<a class="code" href="cfs_8h.html#a30">cfserrno</a>;
00583         }
00584         <a class="code" href="cfs_8h.html#a21">become</a>(NULL);
00585         <span class="keywordflow">return</span> (&amp;ret);
00586 }
00587 
00588 
00589 nfsstat *
00590 nfsproc_rename_2(ap,rp)
00591      renameargs *ap;
00592      <a class="code" href="cfs__adm_8c.html#a0">SR</a> <a class="code" href="cfs__nfs_8c.html#a2">rp</a>;
00593 {
00594         <span class="keyword">static</span> nfsstat ret;
00595         <span class="keywordtype">int</span> <a class="code" href="cfs__fh_8c.html#a20">uid</a>;
00596         <span class="keywordtype">char</span> s1[NFS_MAXPATHLEN+1], s2[NFS_MAXPATHLEN+1];
00597         <span class="keywordtype">char</span> *<a class="code" href="cfs__fh_8c.html#a0">s</a>;
00598         <a class="code" href="structcfskey.html">cfskey</a> *<a class="code" href="mcg_8c.html#a0">key</a>;
00599         <span class="keywordtype">int</span> ht;
00600         <a class="code" href="structcfs__fileid.html">cfs_fileid</a> *fromh, *toh;
00601 
00602 <span class="preprocessor">#ifdef DEBUG</span>
00603 <span class="preprocessor"></span>        printf(<span class="stringliteral">"rename:\n"</span>);
00604 <span class="preprocessor">#endif</span>
00605 <span class="preprocessor"></span>        <span class="keywordflow">if</span> ((ht=htype(fromh=<a class="code" href="cfs_8h.html#a41">geth</a>(&amp;ap-&gt;from.dir)))!=<a class="code" href="cfs_8h.html#a0">H_REG</a>) {
00606                 ret=<a class="code" href="cfs__nfs_8c.html#a0">herr</a>(ht);
00607                 <span class="keywordflow">return</span> &amp;ret;
00608         }
00609         <a class="code" href="cfs__fh_8c.html#a20">uid</a>=ruid(rp);
00610         <span class="comment">/* just make sure these are the same fs instance</span>
00611 <span class="comment">           implicitly, this checks for a valid todir */</span>
00612         <span class="keywordflow">if</span> (<a class="code" href="cfs__fh_8c.html#a32">iid</a>(fromh) != <a class="code" href="cfs__fh_8c.html#a32">iid</a>(toh=<a class="code" href="cfs_8h.html#a41">geth</a>(&amp;ap-&gt;to.dir))) {
00613                 <span class="comment">/* what to return? there's no NFSERR_XDEV */</span>
00614                 ret = NFSERR_EXIST;
00615                 <span class="keywordflow">return</span> &amp;ret;
00616         }
00617         <a class="code" href="cfs_8h.html#a21">become</a>(rp);     <span class="comment">/* become the user */</span>
00618 
00619         <span class="keywordflow">if</span> ((<a class="code" href="mcg_8c.html#a0">key</a>=<a class="code" href="cfs_8h.html#a22">keyof</a>(fromh)) == NULL)
00620                 ret=<a class="code" href="cfs_8h.html#a30">cfserrno</a>;
00621         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (((<a class="code" href="cfs__fh_8c.html#a0">s</a>=<a class="code" href="cfs_8h.html#a39">encryptname</a>(key,ap-&gt;from.name)) == NULL) ||
00622                  (strcpy(s1,s)==NULL))
00623                 ret=<a class="code" href="cfs_8h.html#a30">cfserrno</a>;
00624         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (((<a class="code" href="cfs__fh_8c.html#a0">s</a>=<a class="code" href="cfs_8h.html#a39">encryptname</a>(key,ap-&gt;to.name)) == NULL) ||
00625                  (strcpy(s2,s)==NULL))
00626                 ret=<a class="code" href="cfs_8h.html#a30">cfserrno</a>;
00627         <span class="comment">/* if s1 already has a handle, rename updates its underlying name */</span>
00628         <span class="keywordflow">else</span> <span class="keywordflow">switch</span> (fhrename(fromh,s1,
00629                               toh,s2)) {
00630             <span class="keywordflow">case</span> -1:
00631                 ret=cfsno(errno);
00632                 <span class="keywordflow">break</span>;
00633             <span class="keywordflow">case</span> -2:
00634                 ret=<a class="code" href="cfs_8h.html#a30">cfserrno</a>;
00635                 <span class="keywordflow">break</span>;
00636             <span class="keywordflow">default</span>:
00637                 ret=NFS_OK;
00638         }
00639 
00640         <a class="code" href="cfs_8h.html#a21">become</a>(NULL);
00641         <span class="keywordflow">return</span> (&amp;ret);
00642 }
00643 
00644 
00645 nfsstat *
00646 nfsproc_link_2(ap,rp)
00647      linkargs *ap;
00648      <a class="code" href="cfs__adm_8c.html#a0">SR</a> <a class="code" href="cfs__nfs_8c.html#a2">rp</a>;
00649 {
00650         <span class="keyword">static</span> nfsstat ret;
00651         <span class="keywordtype">int</span> <a class="code" href="cfs__fh_8c.html#a20">uid</a>;
00652         <span class="keywordtype">char</span> *<a class="code" href="cfs__fh_8c.html#a0">s</a>;
00653         <a class="code" href="structcfskey.html">cfskey</a> *<a class="code" href="mcg_8c.html#a0">key</a>;
00654         <span class="keywordtype">int</span> ht;
00655         <a class="code" href="structcfs__fileid.html">cfs_fileid</a> *fromh, *toh;
00656 
00657 <span class="preprocessor">#ifdef DEBUG</span>
00658 <span class="preprocessor"></span>        printf(<span class="stringliteral">"link:\n"</span>);
00659 <span class="preprocessor">#endif</span>
00660 <span class="preprocessor"></span>        <span class="keywordflow">if</span> ((ht=htype(fromh=<a class="code" href="cfs_8h.html#a41">geth</a>(&amp;ap-&gt;from)))!=<a class="code" href="cfs_8h.html#a0">H_REG</a>) {
00661                 ret=<a class="code" href="cfs__nfs_8c.html#a0">herr</a>(ht);
00662                 <span class="keywordflow">return</span> &amp;ret;
00663         }
00664         <a class="code" href="cfs__fh_8c.html#a20">uid</a>=ruid(rp);
00665         <span class="comment">/* again, make sure these are the same fs instance</span>
00666 <span class="comment">           implicitly, this checks for a valid todir, since iip</span>
00667 <span class="comment">           returns -1 on error */</span>
00668         <span class="keywordflow">if</span> (<a class="code" href="cfs__fh_8c.html#a32">iid</a>(fromh) != <a class="code" href="cfs__fh_8c.html#a32">iid</a>(toh=<a class="code" href="cfs_8h.html#a41">geth</a>(&amp;ap-&gt;to.dir))) {
00669                 <span class="comment">/* what to return? there's no NFSERR_XDEV */</span>
00670                 ret = NFSERR_EXIST;     <span class="comment">/* got a better idea? */</span>
00671                 <span class="keywordflow">return</span> &amp;ret;
00672         }
00673         <span class="keywordflow">if</span> ((<a class="code" href="mcg_8c.html#a0">key</a>=<a class="code" href="cfs_8h.html#a22">keyof</a>(toh))==NULL) {
00674                 ret=<a class="code" href="cfs_8h.html#a30">cfserrno</a>;
00675                 <span class="keywordflow">return</span> &amp;ret;
00676         }
00677         <a class="code" href="cfs_8h.html#a21">become</a>(rp);
00678         <span class="keywordflow">if</span> ((<a class="code" href="cfs__fh_8c.html#a0">s</a>=<a class="code" href="cfs_8h.html#a39">encryptname</a>(key,ap-&gt;to.name))==NULL)
00679                 ret=<a class="code" href="cfs_8h.html#a30">cfserrno</a>;
00680         <span class="keywordflow">else</span> <span class="keywordflow">switch</span> (fhdohardlink(fromh,toh,s)) {
00681             <span class="keywordflow">case</span> -1:
00682                 ret=cfsno(errno);
00683                 <span class="keywordflow">break</span>;
00684             <span class="keywordflow">case</span> -2:
00685                 ret=<a class="code" href="cfs_8h.html#a30">cfserrno</a>;
00686                 <span class="keywordflow">break</span>;
00687             <span class="keywordflow">default</span>:
00688                 ret=NFS_OK;
00689                 <span class="keywordflow">break</span>;
00690         }
00691         <a class="code" href="cfs_8h.html#a21">become</a>(NULL);
00692         <span class="keywordflow">return</span> (&amp;ret);
00693 }
00694 
00695 
00696 nfsstat *
00697 nfsproc_symlink_2(ap,rp)
00698      symlinkargs *ap;
00699      <a class="code" href="cfs__adm_8c.html#a0">SR</a> <a class="code" href="cfs__nfs_8c.html#a2">rp</a>;
00700 {
00701         <span class="keyword">static</span> nfsstat ret;
00702         <span class="keywordtype">int</span> <a class="code" href="cfs__fh_8c.html#a20">uid</a>;
00703         <span class="keywordtype">char</span> *<a class="code" href="cfs__fh_8c.html#a0">s</a>;
00704         <span class="keywordtype">char</span> s1[NFS_MAXPATHLEN+1], s2[NFS_MAXPATHLEN+1];
00705         <a class="code" href="structcfskey.html">cfskey</a> *<a class="code" href="mcg_8c.html#a0">key</a>;
00706         <span class="keywordtype">int</span> ht;
00707         <a class="code" href="structcfs__fileid.html">cfs_fileid</a> *<a class="code" href="cfs__fh_8c.html#a28">h</a>;
00708 
00709 <span class="preprocessor">#ifdef DEBUG</span>
00710 <span class="preprocessor"></span>        printf(<span class="stringliteral">"symlink:\n"</span>);
00711 <span class="preprocessor">#endif</span>
00712 <span class="preprocessor"></span>        <span class="keywordflow">if</span> ((ht=htype(h=<a class="code" href="cfs_8h.html#a41">geth</a>(&amp;ap-&gt;from.dir)))!=<a class="code" href="cfs_8h.html#a0">H_REG</a>) {
00713                 ret=<a class="code" href="cfs__nfs_8c.html#a0">herr</a>(ht);
00714                 <span class="keywordflow">return</span> &amp;ret;
00715         }
00716         <a class="code" href="cfs__fh_8c.html#a20">uid</a>=ruid(rp);
00717         <span class="keywordflow">if</span> ((<a class="code" href="mcg_8c.html#a0">key</a>=<a class="code" href="cfs_8h.html#a22">keyof</a>(h))==NULL) {
00718                 ret=<a class="code" href="cfs_8h.html#a30">cfserrno</a>;
00719                 <span class="keywordflow">return</span> &amp;ret;
00720         }
00721         <a class="code" href="cfs_8h.html#a21">become</a>(rp);
00722         <span class="keywordflow">if</span> ((<a class="code" href="cfs__fh_8c.html#a0">s</a>=<a class="code" href="cfs_8h.html#a39">encryptname</a>(key,ap-&gt;from.name))==NULL)
00723                 ret=<a class="code" href="cfs_8h.html#a30">cfserrno</a>;
00724         <span class="keywordflow">else</span> {
00725                 strcpy(s1,s);
00726                 <a class="code" href="cfs__fh_8c.html#a0">s</a>=<a class="code" href="cfs_8h.html#a39">encryptname</a>(key,ap-&gt;to); <span class="comment">/* can't fail */</span>
00727                 strcpy(s2,s);
00728                 <span class="comment">/* ignore the attributes stuff */</span>
00729                 <span class="keywordflow">switch</span> (fhdosymlink(h,s1,s2)) {
00730                     <span class="keywordflow">case</span> -1:
00731                         ret=cfsno(errno);
00732                         <span class="keywordflow">break</span>;
00733                     <span class="keywordflow">case</span> -2:
00734                         ret=<a class="code" href="cfs_8h.html#a30">cfserrno</a>;
00735                         <span class="keywordflow">break</span>;
00736                     <span class="keywordflow">default</span>:
00737                         ret=NFS_OK;
00738                         <span class="keywordflow">break</span>;
00739                 }
00740         }
00741         <a class="code" href="cfs_8h.html#a21">become</a>(NULL);
00742         <span class="keywordflow">return</span> (&amp;ret);
00743 }
00744 
00745 diropres *
00746 nfsproc_mkdir_2(ap,rp)
00747      createargs *ap;
00748      <a class="code" href="cfs__adm_8c.html#a0">SR</a> <a class="code" href="cfs__nfs_8c.html#a2">rp</a>;
00749 {
00750         <span class="keyword">static</span> diropres ret;
00751         nfs_fh handle;
00752         <span class="keywordtype">char</span> *<a class="code" href="cfs__fh_8c.html#a0">s</a>;
00753         <span class="keywordtype">int</span> <a class="code" href="cfs__fh_8c.html#a20">uid</a>;
00754         <span class="keywordtype">int</span> ht;
00755         <a class="code" href="structcfs__fileid.html">cfs_fileid</a> *<a class="code" href="cfs__fh_8c.html#a28">h</a>, *h2;
00756         <span class="keywordtype">char</span> *<a class="code" href="getpass_8c.html#a3">k</a>;
00757 
00758 <span class="preprocessor">#ifdef DEBUG</span>
00759 <span class="preprocessor"></span>        printf(<span class="stringliteral">"mkdir:\n"</span>);
00760 <span class="preprocessor">#endif</span>
00761 <span class="preprocessor"></span>        <span class="comment">/* this, lookup, create, and the mount protocol are the only ways</span>
00762 <span class="comment">           to create a handle */</span>
00763         <span class="keywordflow">if</span> (!<a class="code" href="cfs__nfs_8c.html#a15">goodsrc</a>(rp)) {
00764                 ret.status=NFSERR_PERM;
00765                 <span class="keywordflow">return</span> &amp;ret;
00766         }
00767         <span class="keywordflow">if</span> ((ht=htype(h=<a class="code" href="cfs_8h.html#a41">geth</a>(&amp;ap-&gt;where.dir)))!=<a class="code" href="cfs_8h.html#a0">H_REG</a>) {
00768                 ret.status=<a class="code" href="cfs__nfs_8c.html#a0">herr</a>(ht);
00769                 <span class="keywordflow">return</span> &amp;ret;
00770         }
00771         <a class="code" href="cfs__fh_8c.html#a20">uid</a>=ruid(rp);
00772         <a class="code" href="cfs_8h.html#a21">become</a>(rp);
00773         
00774         <span class="comment">/* first create the dir entry */</span>
00775         <span class="comment">/* if one already exists, the underlying handle name field gets</span>
00776 <span class="comment">           updated to reflect its new name */</span>
00777 
00778         <a class="code" href="cfs__fh_8c.html#a0">s</a>=<a class="code" href="cfs_8h.html#a39">encryptname</a>(<a class="code" href="cfs_8h.html#a22">keyof</a>(h),ap-&gt;where.name);
00779         <span class="keywordflow">switch</span> (fhmkdirent(h,s,&amp;handle)) {
00780             <span class="keywordflow">case</span> 0:
00781                 <span class="keywordflow">switch</span> (fhsetattr(h2=<a class="code" href="cfs_8h.html#a41">geth</a>(&amp;handle),&amp;ap-&gt;attributes)) {
00782                     <span class="keywordflow">case</span> 0:     <span class="comment">/* ok */</span>
00783                         <span class="comment">/* now do a getattr */</span>          
00784                         <span class="keywordflow">switch</span> (fhstat(h2=<a class="code" href="cfs_8h.html#a41">geth</a>(&amp;handle),
00785                                        &amp;ret.diropres_u.diropres.attributes)) {
00786                             <span class="keywordflow">case</span> 0:
00787                                 bcopy(&amp;handle,&amp;ret.diropres_u.diropres.file,
00788                                       <span class="keyword">sizeof</span>(nfs_fh));
00789                                 ret.status=NFS_OK;
00790                                 <span class="keywordflow">break</span>;
00791                             <span class="keywordflow">case</span> -1:
00792                                 ret.status=cfsno(errno);
00793                                 <span class="keywordflow">break</span>;
00794                             <span class="keywordflow">default</span>:
00795                                 ret.status=<a class="code" href="cfs_8h.html#a30">cfserrno</a>;
00796                                 <span class="keywordflow">break</span>;
00797                         }
00798                         <span class="keywordflow">break</span>;
00799                     <span class="keywordflow">case</span> -1:    <span class="comment">/* error from syscall */</span>
00800                         ret.status=cfsno(errno);
00801                         <span class="keywordflow">break</span>;
00802                     <span class="keywordflow">default</span>:    <span class="comment">/* bad handle, probably */</span>
00803                         ret.status=<a class="code" href="cfs_8h.html#a30">cfserrno</a>;
00804                         <span class="keywordflow">break</span>;
00805                 }
00806                 <span class="keywordflow">break</span>;
00807             <span class="keywordflow">case</span> -1:
00808                 ret.status=cfsno(errno);
00809                 <span class="keywordflow">break</span>;
00810             <span class="keywordflow">default</span>:
00811                 ret.status=<a class="code" href="cfs_8h.html#a30">cfserrno</a>;
00812                 <span class="keywordflow">break</span>;
00813         }
00814         <a class="code" href="cfs_8h.html#a21">become</a>(NULL);
00815         <span class="keywordflow">return</span> (&amp;ret);
00816 }
00817 
00818 
00819 nfsstat *
00820 nfsproc_rmdir_2(ap,rp)
00821      diropargs *ap;
00822      <a class="code" href="cfs__adm_8c.html#a0">SR</a> <a class="code" href="cfs__nfs_8c.html#a2">rp</a>;
00823 {
00824         <span class="keyword">static</span> nfsstat ret;
00825         <span class="keywordtype">char</span> *<a class="code" href="cfs__fh_8c.html#a0">s</a>;
00826         <a class="code" href="structcfskey.html">cfskey</a> *<a class="code" href="mcg_8c.html#a0">key</a>;
00827         <span class="keywordtype">int</span> <a class="code" href="cfs__fh_8c.html#a20">uid</a>;
00828         <span class="keywordtype">int</span> ht;
00829         <a class="code" href="structcfs__fileid.html">cfs_fileid</a> *<a class="code" href="cfs__fh_8c.html#a28">h</a>;
00830 
00831 <span class="preprocessor">#ifdef DEBUG</span>
00832 <span class="preprocessor"></span>        printf(<span class="stringliteral">"rmdir:\n"</span>);
00833 <span class="preprocessor">#endif</span>
00834 <span class="preprocessor"></span>        <span class="keywordflow">if</span> ((ht=htype(h=<a class="code" href="cfs_8h.html#a41">geth</a>(&amp;ap-&gt;dir)))!=<a class="code" href="cfs_8h.html#a0">H_REG</a>) {
00835                 ret=<a class="code" href="cfs__nfs_8c.html#a0">herr</a>(ht);
00836                 <span class="keywordflow">return</span> &amp;ret;
00837         }
00838         <a class="code" href="cfs__fh_8c.html#a20">uid</a>=ruid(rp);
00839         <a class="code" href="cfs_8h.html#a21">become</a>(rp);     <span class="comment">/* become the user */</span>
00840         <span class="comment">/* first encrypt the name */</span>
00841         <a class="code" href="mcg_8c.html#a0">key</a>=<a class="code" href="cfs_8h.html#a22">keyof</a>(h);
00842         <span class="keywordflow">if</span> (<a class="code" href="mcg_8c.html#a0">key</a>==NULL) {
00843                 ret=<a class="code" href="cfs_8h.html#a30">cfserrno</a>;
00844         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((<a class="code" href="cfs__fh_8c.html#a0">s</a>=<a class="code" href="cfs_8h.html#a39">encryptname</a>(key,ap-&gt;name)) == NULL) {
00845                 ret=NFSERR_NOENT; <span class="comment">/* close enough */</span>
00846         } <span class="keywordflow">else</span> <span class="keywordflow">switch</span> (fhdeletedir(h,s)) {
00847             <span class="keywordflow">case</span> 0:
00848                 ret=NFS_OK;
00849                 <span class="keywordflow">break</span>;
00850             <span class="keywordflow">case</span> -1:
00851                 ret=cfsno(errno);
00852                 <span class="keywordflow">break</span>;
00853             <span class="keywordflow">default</span>:
00854                 ret=<a class="code" href="cfs_8h.html#a30">cfserrno</a>;
00855         }
00856         <a class="code" href="cfs_8h.html#a21">become</a>(NULL);
00857         <span class="keywordflow">return</span> (&amp;ret);
00858 }
00859 
00860 <span class="preprocessor">#define MAXENTRIES 128</span>
00861 <span class="preprocessor"></span><span class="preprocessor">#define MAXENTSIZE (NFS_MAXNAMLEN + sizeof(entry) + 32)</span>
00862 <span class="preprocessor"></span><span class="preprocessor">#define dentsize(s) (strlen(s) + sizeof(entry) + 32)</span>
00863 <span class="preprocessor"></span>
00864 <span class="comment">/* #define cfsclosedir(x) fhclosedir(x) */</span>
00865 
00866 readdirres *
00867 nfsproc_readdir_2(ap,rp)
00868      readdirargs *ap;
00869      <a class="code" href="cfs__adm_8c.html#a0">SR</a> <a class="code" href="cfs__nfs_8c.html#a2">rp</a>;
00870 {
00871         <span class="keyword">static</span> readdirres ret;
00872         <span class="keywordtype">int</span> <a class="code" href="cfs__fh_8c.html#a20">uid</a>;
00873         <span class="keywordtype">int</span> ht;
00874         <span class="keyword">static</span> entry entrytab[MAXENTRIES];      <span class="comment">/* just deal w/ it staticaly */</span>
00875         <span class="keyword">typedef</span> <span class="keywordtype">char</span> str[NFS_MAXNAMLEN+1];
00876         <span class="keyword">static</span> str names[MAXENTRIES];
00877         <span class="keyword">static</span> DIR *dp=NULL;
00878         <span class="keyword">static</span> <span class="keyword">struct </span>dirent *dent;
00879         entry **prev;
00880         <span class="keywordtype">long</span> loc;
00881         <span class="keywordtype">char</span> s1[NFS_MAXNAMLEN+1];
00882         <span class="keywordtype">char</span> *<a class="code" href="cfs__fh_8c.html#a0">s</a>;
00883         <a class="code" href="structcfskey.html">cfskey</a> *<a class="code" href="mcg_8c.html#a0">key</a>;
00884         <span class="keyword">static</span> <span class="keywordtype">long</span> <a class="code" href="cfs__nfs_8c.html#a8">curcookie</a>=0;
00885         <span class="keywordtype">long</span> <a class="code" href="cfs__nfs_8c.html#a9">cookie</a>;
00886         <span class="keywordtype">int</span> eof;
00887         <span class="keywordtype">int</span> ne;
00888         <span class="keywordtype">int</span> bytes;
00889         DIR *<a class="code" href="cfs__nfs_8c.html#a14">cfsopendir</a>();
00890         <a class="code" href="structcfs__fileid.html">cfs_fileid</a> *<a class="code" href="cfs__fh_8c.html#a28">h</a>;
00891         <span class="keyword">static</span> <span class="keywordtype">int</span> fid= -10;
00892 
00893 <span class="preprocessor">#ifdef DEBUG</span>
00894 <span class="preprocessor"></span>        printf(<span class="stringliteral">"readdir:\n"</span>);
00895 <span class="preprocessor">#endif</span>
00896 <span class="preprocessor"></span>        <span class="keywordflow">if</span> ((ht=htype(h=<a class="code" href="cfs_8h.html#a41">geth</a>(&amp;ap-&gt;dir)))!=<a class="code" href="cfs_8h.html#a0">H_REG</a>) {
00897                 <span class="comment">/* this is an ugly hack to deal w/ readdir of root, */</span>
00898                 <span class="keywordflow">if</span> (ht==<a class="code" href="cfs_8h.html#a2">H_ROOT</a>)
00899                         <span class="keywordflow">return</span> (<a class="code" href="cfs__nfs_8c.html#a12">rootreaddir</a>(ap));
00900                 ret.status=<a class="code" href="cfs__nfs_8c.html#a0">herr</a>(ht);
00901                 <span class="keywordflow">return</span> &amp;ret;
00902         }
00903         <a class="code" href="cfs__fh_8c.html#a20">uid</a>=ruid(rp);
00904         <a class="code" href="cfs_8h.html#a21">become</a>(rp);     <span class="comment">/* become the user */</span>
00905 
00906         bytes = ap-&gt;count - MAXENTSIZE;
00907         ne=0;
00908         prev= &amp;ret.readdirres_u.reply.entries;
00909         *prev=NULL;
00910         bcopy(ap-&gt;cookie,&amp;cookie,<span class="keyword">sizeof</span>(cookie));
00911         eof=TRUE;
00912         
00913         <a class="code" href="mcg_8c.html#a0">key</a>=<a class="code" href="cfs_8h.html#a22">keyof</a>(h);
00914         ret.status=NFS_OK;
00915         <span class="keywordflow">if</span> (!((<a class="code" href="cfs__fh_8c.html#a28">h</a>-&gt;<a class="code" href="structfhdata.html#o3">fileid</a>==fid)&amp;&amp;(<a class="code" href="cfs__nfs_8c.html#a9">cookie</a>==<a class="code" href="cfs__nfs_8c.html#a8">curcookie</a>))) {
00916                 <span class="keywordflow">if</span> (dp!=NULL) {
00917                         cfsclosedir(dp);
00918                         dp=NULL;
00919                 }
00920                 <span class="keywordflow">if</span> ((dp=<a class="code" href="cfs__nfs_8c.html#a14">cfsopendir</a>(h,cookie)) == NULL) {
00921                         fid = -10;
00922                         ret.status=<a class="code" href="cfs_8h.html#a30">cfserrno</a>;
00923                 } <span class="keywordflow">else</span> {
00924                         fid=<a class="code" href="cfs__fh_8c.html#a28">h</a>-&gt;<a class="code" href="structfhdata.html#o3">fileid</a>;
00925                         <a class="code" href="cfs__nfs_8c.html#a8">curcookie</a>=<a class="code" href="cfs__nfs_8c.html#a9">cookie</a>;
00926                         dent=readdir(dp);
00927                 }
00928         }
00929         <span class="keywordflow">if</span> (dp!=NULL) <span class="keywordflow">while</span> (dent!=NULL) {
00930                 <a class="code" href="cfs__fh_8c.html#a0">s</a>=<a class="code" href="cfs_8h.html#a40">decryptname</a>(key,dent-&gt;d_name);
00931                 <a class="code" href="cfs__nfs_8c.html#a9">cookie</a>++;
00932                 <span class="keywordflow">if</span> (<a class="code" href="cfs__fh_8c.html#a0">s</a>==NULL) { <span class="comment">/* just skip bogus names */</span>
00933                         dent=readdir(dp);
00934                         <span class="keywordflow">continue</span>;
00935                 }
00936                 eof=FALSE;
00937                 <span class="keywordflow">if</span> (((bytes -= dentsize(s)) &lt; 0) || (ne &gt;= MAXENTRIES))
00938                         <span class="keywordflow">break</span>;
00939                 eof=TRUE;
00940                 strcpy(names[ne],s);
00941                 entrytab[ne].name=names[ne];
00942                 <span class="keywordflow">if</span> (strcmp(s,<span class="stringliteral">"."</span>)==0)   <span class="comment">/* me */</span>
00943                         entrytab[ne].fileid=fhid(h);
00944                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(s,<span class="stringliteral">".."</span>)==0)     <span class="comment">/* parent */</span>
00945                         entrytab[ne].fileid=fhpid(h);
00946                 <span class="keywordflow">else</span> entrytab[ne].fileid=dent-&gt;d_fileno;
00947                 bcopy(&amp;cookie,entrytab[ne].cookie,<span class="keyword">sizeof</span>(<span class="keywordtype">long</span>));
00948                 *prev = &amp;entrytab[ne];
00949                 prev = &amp;entrytab[ne].nextentry;
00950                 entrytab[ne].nextentry=NULL;
00951                 ne++;
00952                 <a class="code" href="cfs__nfs_8c.html#a8">curcookie</a>++;
00953                 dent=readdir(dp);
00954         }
00955         ret.readdirres_u.reply.eof=eof;
00956         <span class="keywordflow">if</span> (dent==NULL) {
00957                 fid= -10;
00958                 cfsclosedir(dp);
00959                 dp=NULL;
00960         }
00961         <a class="code" href="cfs_8h.html#a21">become</a>(NULL);
00962         <span class="keywordflow">return</span> (&amp;ret);
00963 }
00964 
00965 DIR *curdir;
<a name="l00966"></a><a class="code" href="cfs__nfs_8c.html#a7">00966</a> <span class="keywordtype">int</span> <a class="code" href="cfs__nfs_8c.html#a7">curdirid</a>=0;
<a name="l00967"></a><a class="code" href="cfs__nfs_8c.html#a8">00967</a> <span class="keywordtype">long</span> <a class="code" href="cfs__nfs_8c.html#a8">curcookie</a>;
00968 
00969 DIR *
00970 <a class="code" href="cfs__nfs_8c.html#a14">cfsopendir</a>(dir,cookie)
00971      <a class="code" href="structcfs__fileid.html">cfs_fileid</a> *dir;
<a name="l00972"></a><a class="code" href="cfs__nfs_8c.html#a9">00972</a>      <span class="keywordtype">long</span> <a class="code" href="cfs__nfs_8c.html#a9">cookie</a>;
00973 {
00974         DIR *ret;
00975         DIR *fhopendir();
00976 
00977         <span class="keywordflow">if</span> ((ret=fhopendir(dir))==NULL)
00978                 <span class="keywordflow">return</span> NULL;    <span class="comment">/* fhopendir sets cfserrno */</span>
00979         <span class="comment">/* this is an ugly hack to deal with braindead systems (afs) that can't</span>
00980 <span class="comment">           do seekdir properly.  fortunately, we almost always already have</span>
00981 <span class="comment">           the dir open so we don't have to do this bogosity */</span>
00982         <span class="keywordflow">while</span> (<a class="code" href="cfs__nfs_8c.html#a9">cookie</a>-- &gt; 0)
00983                 readdir(ret);
00984         <span class="keywordflow">return</span> ret;
00985 }
00986 
00987 cfsclosedir(dp)
00988      DIR *dp;
00989 {
00990         fhclosedir(dp);
00991 }
00992 
00993 statfsres *
00994 nfsproc_statfs_2(ap,rp)
00995      nfs_fh *ap;
<a name="l00996"></a><a class="code" href="cfs__nfs_8c.html#a6">00996</a>      <a class="code" href="cfs__adm_8c.html#a0">SR</a> <a class="code" href="cfs__nfs_8c.html#a2">rp</a>;
00997 {
00998         <span class="keyword">static</span> statfsres ret;
00999 
01000 <span class="preprocessor">#ifdef DEBUG</span>
01001 <span class="preprocessor"></span>        printf(<span class="stringliteral">"statfs: %s\n"</span>,<a class="code" href="cfs__nfs_8c.html#a11">pfh</a>(ap));
01002 <span class="preprocessor">#endif</span>
01003 <span class="preprocessor"></span>        setstatfsokres(&amp;ret.statfsres_u.reply);
01004         ret.status=NFS_OK;
01005         <span class="keywordflow">return</span> (&amp;ret);
01006 }
01007 
01008 rootgetattr(f)
01009         <span class="keyword">struct </span>fattr *f;
01010 {
01011         f-&gt;type=NFDIR;
01012         f-&gt;mode=NFSMODE_DIR|0777;
01013         f-&gt;nlink=4;
01014         f-&gt;uid=0;
01015         f-&gt;gid=0;
01016         f-&gt;size=8192;
01017         f-&gt;blocksize=8192;
01018         f-&gt;rdev= -1;
01019         f-&gt;blocks=1;
01020         f-&gt;fsid=0;
01021         f-&gt;fileid=1;
01022         bcopy(&amp;roottime,&amp;f-&gt;atime,<span class="keyword">sizeof</span>(nfstime));
01023         bcopy(&amp;roottime,&amp;f-&gt;mtime,<span class="keyword">sizeof</span>(nfstime));
01024         bcopy(&amp;roottime,&amp;f-&gt;ctime,<span class="keyword">sizeof</span>(nfstime));
01025         
01026 }
01027 
01028 setstatfsokres(s)
01029         statfsokres *<a class="code" href="cfs__fh_8c.html#a0">s</a>;
01030 {
01031         <a class="code" href="cfs__fh_8c.html#a0">s</a>-&gt;tsize=8192;
01032         <a class="code" href="cfs__fh_8c.html#a0">s</a>-&gt;bsize=8192;
01033         <a class="code" href="cfs__fh_8c.html#a0">s</a>-&gt;blocks=0;
01034         <a class="code" href="cfs__fh_8c.html#a0">s</a>-&gt;bfree=0;
01035         <a class="code" href="cfs__fh_8c.html#a0">s</a>-&gt;bavail=0;
01036 }
01037 
01038 <span class="keywordtype">int</span> fhstat(fh,fa)
01039      <a class="code" href="structcfs__fileid.html">cfs_fileid</a> *fh;
<a name="l01040"></a><a class="code" href="cfs__nfs_8c.html#a10">01040</a>      fattr *<a class="code" href="cfs__nfs_8c.html#a10">fa</a>;
01041 {
01042         <span class="keyword">struct </span>stat <a class="code" href="cfs__fh_8c.html#a25">sb</a>;
01043         <span class="keywordtype">int</span> r;
01044         
01045         <span class="keywordflow">if</span> (fh==NULL) {
01046                 <a class="code" href="cfs_8h.html#a30">cfserrno</a>=NFSERR_STALE;
01047                 <span class="keywordflow">return</span> -2;
01048         }
01049         <span class="keywordflow">if</span> (fh== &amp;<a class="code" href="cfs_8h.html#a37">rootnode</a>) {
01050                 rootgetattr(<a class="code" href="cfs__nfs_8c.html#a10">fa</a>);
01051                 <span class="keywordflow">return</span> 0;
01052         }
01053                 
01054         <span class="keywordflow">if</span> ((r=fhgetstat(fh,&amp;<a class="code" href="cfs__fh_8c.html#a25">sb</a>)) != 0)
01055                 <span class="keywordflow">return</span> r;
01056         <a class="code" href="cfs__nfs_8c.html#a10">fa</a>-&gt;type = getftype(<a class="code" href="cfs__fh_8c.html#a25">sb</a>.st_mode);
01057         <a class="code" href="cfs__nfs_8c.html#a10">fa</a>-&gt;mode = fhmode(fh,<a class="code" href="cfs__fh_8c.html#a25">sb</a>.st_mode);
01058         <a class="code" href="cfs__nfs_8c.html#a10">fa</a>-&gt;nlink = <a class="code" href="cfs__fh_8c.html#a25">sb</a>.st_nlink;
01059         <a class="code" href="cfs__nfs_8c.html#a10">fa</a>-&gt;uid = fhowner(fh,<a class="code" href="cfs__fh_8c.html#a25">sb</a>.st_uid);
01060         <a class="code" href="cfs__nfs_8c.html#a10">fa</a>-&gt;gid = <a class="code" href="cfs__fh_8c.html#a25">sb</a>.st_gid;
01061         <a class="code" href="cfs__nfs_8c.html#a10">fa</a>-&gt;size = <a class="code" href="cfs__fh_8c.html#a25">sb</a>.st_size; <span class="comment">/* already tweeked */</span>
01062 <span class="preprocessor">#ifdef irix</span>
01063 <span class="preprocessor"></span>    <a class="code" href="cfs__nfs_8c.html#a10">fa</a>-&gt;blocksize = 512;
01064     <a class="code" href="cfs__nfs_8c.html#a10">fa</a>-&gt;blocks = (<a class="code" href="cfs__fh_8c.html#a25">sb</a>.st_size + 511)/512;
01065 <span class="preprocessor">#else</span>
01066 <span class="preprocessor"></span>        <a class="code" href="cfs__nfs_8c.html#a10">fa</a>-&gt;blocksize = <a class="code" href="cfs__fh_8c.html#a25">sb</a>.st_blksize;
01067         <a class="code" href="cfs__nfs_8c.html#a10">fa</a>-&gt;blocks = <a class="code" href="cfs__fh_8c.html#a25">sb</a>.st_blocks;
01068 <span class="preprocessor">#endif</span>
01069 <span class="preprocessor"></span>        <a class="code" href="cfs__nfs_8c.html#a10">fa</a>-&gt;rdev = <a class="code" href="cfs__fh_8c.html#a25">sb</a>.st_rdev;
01070         <a class="code" href="cfs__nfs_8c.html#a10">fa</a>-&gt;fsid = <a class="code" href="cfs__fh_8c.html#a32">iid</a>(fh); <span class="comment">/* we return the instance id */</span>
01071         <a class="code" href="cfs__nfs_8c.html#a10">fa</a>-&gt;fileid = fhid(fh); <span class="comment">/* inode or 0-i for iroots */</span>
01072         bcopy(&amp;<a class="code" href="cfs__fh_8c.html#a25">sb</a>.st_atime,&amp;<a class="code" href="cfs__nfs_8c.html#a10">fa</a>-&gt;atime,<span class="keyword">sizeof</span>(time_t));
01073         bcopy(&amp;<a class="code" href="cfs__fh_8c.html#a25">sb</a>.st_mtime,&amp;<a class="code" href="cfs__nfs_8c.html#a10">fa</a>-&gt;mtime,<span class="keyword">sizeof</span>(time_t));
01074         bcopy(&amp;<a class="code" href="cfs__fh_8c.html#a25">sb</a>.st_ctime,&amp;<a class="code" href="cfs__nfs_8c.html#a10">fa</a>-&gt;ctime,<span class="keyword">sizeof</span>(time_t));
01075         <span class="keywordflow">return</span> 0;
01076 }
01077 
01078 <span class="comment">/* return uid associated w/ rpc call - unix style only for now */</span>
01079 <span class="comment">/* note that this really doesnt belong here */</span>
01080 <span class="keywordtype">int</span>
01081 ruid(rp)
01082      <a class="code" href="cfs__adm_8c.html#a0">SR</a> <a class="code" href="cfs__nfs_8c.html#a2">rp</a>;
01083 {
01084         <span class="keyword">struct </span>authunix_parms *cred;
01085 
01086         <span class="keywordflow">if</span> (<a class="code" href="cfs__nfs_8c.html#a2">rp</a>-&gt;rq_cred.oa_flavor != AUTH_UNIX)
01087                 <span class="keywordflow">return</span> -1;
01088         cred=(<span class="keyword">struct </span>authunix_parms *) <a class="code" href="cfs__nfs_8c.html#a2">rp</a>-&gt;rq_clntcred;
01089         <span class="keywordflow">return</span> cred-&gt;aup_uid;
01090 }
01091 
01092 <span class="keywordtype">int</span>
01093 rgid(rp)
01094      <a class="code" href="cfs__adm_8c.html#a0">SR</a> <a class="code" href="cfs__nfs_8c.html#a2">rp</a>;
01095 {
01096         <span class="keyword">struct </span>authunix_parms *cred;
01097 
01098         <span class="keywordflow">if</span> (<a class="code" href="cfs__nfs_8c.html#a2">rp</a>-&gt;rq_cred.oa_flavor != AUTH_UNIX)
01099                 <span class="keywordflow">return</span> -1;
01100         cred=(<span class="keyword">struct </span>authunix_parms *) <a class="code" href="cfs__nfs_8c.html#a2">rp</a>-&gt;rq_clntcred;
01101         <span class="keywordflow">return</span> cred-&gt;aup_gid;
01102 }
01103 
01104 <span class="comment">/* this is ugly, since it duplicates much of the code</span>
01105 <span class="comment">   above in lookup, but it does the job */</span>
01106 diropres *
01107 rootlookup(s)
01108      <span class="keywordtype">char</span> *<a class="code" href="cfs__fh_8c.html#a0">s</a>;
01109 {
01110         <span class="keyword">static</span> diropres ret;
01111         nfs_fh *handle;
01112         
01113         handle = &amp;ret.diropres_u.diropres.file;
01114         <span class="keywordflow">switch</span> (fhrootlook(s,handle)) {
01115             <span class="keywordflow">case</span> 0:     <span class="comment">/* found it */</span>
01116                 <span class="comment">/* now do a getattr - handle is an instance root, which</span>
01117 <span class="comment">                   is treated normally */</span>
01118                 <span class="keywordflow">switch</span> (fhstat(<a class="code" href="cfs_8h.html#a41">geth</a>(handle),
01119                                &amp;ret.diropres_u.diropres.attributes)) {
01120                     <span class="keywordflow">case</span> 0:
01121                         ret.status=NFS_OK;
01122                         <span class="comment">/* stat is already in attributes field */</span>
01123                         <span class="keywordflow">break</span>;
01124                     <span class="keywordflow">case</span> -1:    <span class="comment">/* couldn't open file for some reason */</span>
01125                         ret.status=cfsno(errno);
01126                         <span class="keywordflow">break</span>;
01127                     <span class="keywordflow">default</span>:    <span class="comment">/* shouldn't happen */</span>
01128                         ret.status=<a class="code" href="cfs_8h.html#a30">cfserrno</a>;
01129                         <span class="keywordflow">break</span>;
01130                 }
01131                 <span class="keywordflow">break</span>;
01132             <span class="keywordflow">case</span> -1:    <span class="comment">/* some parent dir went away, probably */</span>
01133                 ret.status=cfsno(errno);
01134                 <span class="keywordflow">break</span>;
01135             <span class="keywordflow">default</span>:    <span class="comment">/* bad parent handle or notfound, probably */</span>
01136                 ret.status=<a class="code" href="cfs_8h.html#a30">cfserrno</a>;
01137                 <span class="keywordflow">break</span>;
01138         }
01139         <span class="keywordflow">return</span> (&amp;ret);
01140 }
01141 
01142 <span class="comment">/* ugly ugly ugly - duplicates fair bit of code from readdir, but at least</span>
01143 <span class="comment">   it works */</span>
01144 readdirres *
01145 <a class="code" href="cfs__nfs_8c.html#a12">rootreaddir</a>(ap)
01146     readdirargs *ap;
01147 
01148 {
01149         <span class="keyword">static</span> readdirres ret;
01150         <span class="keyword">static</span> entry entrytab[MAXENTRIES];      <span class="comment">/* just deal w/ it staticaly */</span>
01151         <span class="keyword">typedef</span> <span class="keywordtype">char</span> str[NFS_MAXNAMLEN+1];
01152         <span class="keyword">static</span> str names[MAXENTRIES];
01153         entry **prev;
01154         <span class="keywordtype">long</span> <a class="code" href="cfs__nfs_8c.html#a9">cookie</a>;
01155         <span class="keywordtype">int</span> eof;
01156         <span class="keywordtype">int</span> ne;
01157         <span class="keywordtype">int</span> bytes;
01158         <a class="code" href="structcfs__fileid.html">cfs_fileid</a> *<a class="code" href="cfs__fh_8c.html#a28">h</a>;
01159         <span class="keyword">struct </span>dirent *dent;
01160         <span class="keyword">struct </span>dirent *rootrd();
01161 
01162         bytes = ap-&gt;count - MAXENTSIZE;
01163         ne=0;
01164         prev= &amp;ret.readdirres_u.reply.entries;
01165         *prev=NULL;
01166         bcopy(ap-&gt;cookie,&amp;cookie,<span class="keyword">sizeof</span>(<span class="keywordtype">long</span>));
01167         eof=1;
01168         
01169         ret.status=NFS_OK;
01170         <span class="keywordflow">while</span> ((dent=rootrd(cookie))!=NULL) {
01171                 eof=0;
01172                 <span class="keywordflow">if</span> (((bytes -= dentsize(dent-&gt;d_name))&lt;0)||(ne &gt;= MAXENTRIES)){
01173                         <span class="keywordflow">break</span>;
01174                 }
01175                 eof=1;
01176                 strcpy(names[ne],dent-&gt;d_name);
01177                 entrytab[ne].name=names[ne];
01178                 <span class="keywordflow">if</span> (strcmp(dent-&gt;d_name,<span class="stringliteral">"."</span>)==0)        <span class="comment">/* me */</span>
01179                         entrytab[ne].fileid=1;
01180                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(dent-&gt;d_name,<span class="stringliteral">".."</span>)==0) <span class="comment">/* parent, also me */</span>
01181                         entrytab[ne].fileid=1;
01182                 <span class="keywordflow">else</span> entrytab[ne].fileid=dent-&gt;d_fileno;
01183                 <a class="code" href="cfs__nfs_8c.html#a9">cookie</a>=dent-&gt;d_reclen;  <span class="comment">/* may not work everywhere */</span>
01184                 *prev = &amp;entrytab[ne];
01185                 bcopy(&amp;cookie,entrytab[ne].cookie,<span class="keyword">sizeof</span>(<span class="keywordtype">long</span>));
01186                 prev = &amp;entrytab[ne].nextentry;
01187                 entrytab[ne].nextentry=NULL;
01188                 ne++;
01189         }
01190         ret.readdirres_u.reply.eof=eof;
01191         <span class="keywordflow">return</span> (&amp;ret);
01192 }
01193 
01194 <span class="keyword">extern</span> <span class="keyword">struct </span>in_addr <a class="code" href="ccat_8c.html#a0">validhost</a>;
01195 
01196 <a class="code" href="cfs__nfs_8c.html#a15">goodsrc</a>(rp)
01197      <a class="code" href="cfs__adm_8c.html#a0">SR</a> <a class="code" href="cfs__nfs_8c.html#a2">rp</a>;
01198 {
01199         <span class="keyword">struct </span>in_addr ia;
01200         <span class="keyword">struct </span>in_addr *ip;
01201 
01202         <span class="keywordflow">if</span> (svc_getcaller(<a class="code" href="cfs__nfs_8c.html#a2">rp</a>-&gt;rq_xprt)-&gt;sin_addr.s_addr != <a class="code" href="ccat_8c.html#a0">validhost</a>.s_addr) {
01203                 fprintf(stderr,<span class="stringliteral">"bad addr! %x !- %x\n"</span>,
01204                   svc_getcaller(<a class="code" href="cfs__nfs_8c.html#a2">rp</a>-&gt;rq_xprt)-&gt;sin_addr.s_addr,<a class="code" href="ccat_8c.html#a0">validhost</a>.s_addr);
01205                 <span class="keywordflow">return</span> 0;
01206         }
01207         <span class="keywordflow">if</span> (<a class="code" href="cfs__nfs_8c.html#a2">rp</a>-&gt;rq_cred.oa_flavor != AUTH_UNIX)
01208                 <span class="keywordflow">return</span> 0;       <span class="comment">/* bolster defense against portmap bug */</span>
01209 <span class="preprocessor">#ifndef ANYPORT</span>
01210 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (ntohs(svc_getcaller(<a class="code" href="cfs__nfs_8c.html#a2">rp</a>-&gt;rq_xprt)-&gt;sin_port) &gt; 1023) {
01211                 fprintf(stderr,<span class="stringliteral">"bad port! %d\n"</span>, ntohs(svc_getcaller(<a class="code" href="cfs__nfs_8c.html#a2">rp</a>-&gt;rq_xprt)-&gt;sin_port));
01212                 <span class="keywordflow">return</span> 0;
01213         }
01214 <span class="preprocessor">#endif</span>
01215 <span class="preprocessor"></span>        <span class="keywordflow">return</span> 1;
01216 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Tue Jun 15 09:59:03 2004 for CFS by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>

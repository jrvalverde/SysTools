<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="es" lang="es"><head>
<link rel="stylesheet" type="text/css" href="C%C3%A1lculo%20num%C3%A9rico%20con%20bc_files/clean.css">
<meta http-equiv="Content-type" content="text/html; charset=UTF-8">

<title>Cálculo numérico con bc</title>
</head>
<body>

<div id="page">

 <h1>Cálculo numérico con bc</h1>

<h2 class="author">Marc Meléndez Schofield</h2>


<p class="first">Para la mayor parte de los cálculos numéricos que se pueden llegar
a necesitar en el estudio de una carrera científica como ciencias
físicas o matemáticas, no es necesario disponer de un ordenador
potente, ni de software demasiado avanzado. Este artículo muestra
cómo llevar a cabo cálculos relativamente interesantes con una
simple calculadora de línea de comandos llamada <strong>bc</strong>.</p>

  <p><strong>bc</strong> viene instalado con la mayor parte de los sistemas inspirados
en Unix (como Linux, FreeBSD, etc.). Tiene la ventaja de ser un
programa sencillo y compacto, además del hecho de que los cálculos
son interpretados (en otras palabras, no hace falta compilar). Sin
embargo, tiene el inconveniente de ser un poco limitado (no se
pueden crear matrices bidimensionales, por ejemplo).</p>

<div class="contents">
<h3 class="contents">Contenidos</h3>
<ol>
<li><a href="#s1">bc básico</a>
  <ul>
    <li>1.1 <a href="#s1.1 ">Operaciones aritméticas</a></li>
    <li>1.2 <a href="#s1.2">Variables</a></li>
    <li>1.3 <a href="#s1.3">Funciones matemáticas</a></li>
  </ul>
</li>
<li><a href="#s2">Definición de funciones</a></li>
<li><a href="#s3">Creación de scripts</a>
  <ul>
    <li>3.1 <a href="#s3.1 ">Condiciones</a></li>
    <li>3.2 <a href="#s3.2">Bucles</a>
      <ul>
         <li>3.2.1 <a href="#s3.2.1">for</a></li>
         <li>3.2.2 <a href="#s3.2.2">while</a></li>
         <li>3.2.3 <a href="#s3.2.3">Advertencia</a></li>
      </ul>
    </li>
    <li>3.3 <a href="#s3.3">Matrices</a></li>
    <li>3.4 <a href="#s3.4">Variables auto</a></li>
    <li>3.5 <a href="#s3.5">Instrucción read()</a></li>
    <li>3.6 <a href="#s3.6">Pasar matrices por referencia</a></li>
  </ul>
</li>
<li><a href="#s4">Ejemplos</a>
  <ul>
    <li>4.1 <a href="#s4.1">Matemáticas</a>
      <ul>
         <li>4.1.1 <a href="#s4.1.1">Teoría de números</a></li>
         <li>4.1.2 <a href="#s4.1.2">Probabilidad y estadística</a></li>
         <li>4.1.3 <a href="#s4.1.3">Cálculo</a></li>
         <li>4.1.4 <a href="#s4.1.4">Números complejos</a></li>
         <li>4.1.5 <a href="#s4.1.5">Vectores</a></li>
      </ul>
    </li>
    <li>4.2 <a href="#s4.2">Física</a>
      <ul>
         <li>4.2.1 <a href="#s4.2.1">Dinámica de una partícula</a></li>
         <li>4.2.2 <a href="#s4.2.2">Campos de fuerzas</a></li>
      </ul>
    </li>
  </ul>
</li>
</ol>
</div>

<h2 id="s1">1. bc básico</h2>

<p>Para entrar en <strong>bc</strong>, simplemente ejecuta el comando <strong>bc</strong> desde la línea
de comandos.</p>

<h3 id="s1.1">1.1 Operaciones aritméticas</h3>

<p>A continuación, escribe 5+3 y pulsa enter.</p>

<pre class="terminal">    &gt; bc
    5+3
    8
</pre>

<p>La respuesta se muestra en la línea siguiente. Se pueden utilizar
los paréntesis para agrupar términos.</p>

<pre class="terminal">    (5+10)*2
    30
    5+10*2
    25
</pre>

<p>Para calcular una potencia, se utiliza el signo ^.</p>

<pre class="terminal">    2^5
    32
</pre>

<p>La división puede resultar desconcertante en un primer momento.</p>

<pre class="terminal">    7/5
    1
</pre>

<p>Esto es debido a que en la solución se están ignorando los decimales.
Por defecto, obtenemos el cociente entero. El resto de la división
se puede calcular con el operador %.</p>

<pre class="terminal">    7%5
    2
</pre>

<p>El número de decimales de los cálculos se controla con la
variable scale. Si queremos dos decimales,</p>

<pre class="terminal">    scale=2
    7/5
    1.40
</pre>

<p>La raíz cuadrada se calcula con la función sqrt (del inglés
"square root").</p>

<pre class="terminal">    sqrt(4)
    2
</pre>

<p>Para salir del programa, escribe quit y pulsa enter.</p>

<h3 id="s1.2">1.2 Variables</h3>

<p>Vamos a suponer que queremos calcular la solución del
problema siguiente:</p>

    <blockquote><p>Calcular la fuerza eléctrica que ejerce una carga de 
    1 microcoulombio sobre una carga de 2,5 microcoulombios
    situada en el vacío a 5 centímetros de ella.</p></blockquote>

<p>Podríamos aplicar la ley de Coulomb (F = K(q1·q2)/r<sup>2</sup>),</p>

<pre class="terminal">    scale=7
    9*10^9*1*10^-6*2.5*10^-6/0.05^2
    9.0000000
</pre>

<p class="continue">
pero es más legible definir los valores por separado, y
utilizar una expresión simbólica (nótese que las variables
se representan con letras minúsculas).</p>

<pre class="terminal">    scale = 7
    k = 9*10^9
    q1 = 1*10^-6
    q2 = 2.5*10^-6
    r = 0.05
    k*q1*q2/r^2
    9.0000000
</pre>

<p>También se podría haber definido la variable f, así:</p>

<pre class="terminal">    f = k*q1*q2/r^2
    f
    9.0000000
</pre>

<p>Hay que tener cuidado con las expresiones del tipo "3a", que
devuelven un mensaje de error. Los productos se deben escribir
explícitamente: 3*a.</p>

<pre class="terminal">    a=3
    3a
    (standard_in) 21: syntax error
    3*a
    9
</pre>

<h3 id="s1.3">1.3 Funciones matemáticas</h3>

<p>Si, en lugar de ejecutar el comando <strong>bc</strong> a secas, se utiliza la
opción -l (es decir, escribimos el comando bc -l), <strong>bc</strong> carga
su librería matemática, que incluye las funciones seno, coseno,
arco tangente, logaritmo natural, exponencial y de Bessel.</p>

  <p>Podemos calcular los logaritmos neperianos de 1 y 2 así:</p>

<pre class="terminal">    &gt; bc -l
    l(1)
    0
    l(2)
    .69314718055994530941
</pre>

<p>Las funciones incluídas en la librería matemática son:</p>

<ul>
<li>s(x)   Seno de x (x en radianes).</li>
<li>c(x)   Coseno de x (x en radianes).</li>
<li>a(x)   Arco tangente de x, (devuelve un valor en radianes).</li>
<li>l(x)   Logaritmo natural x.</li>
<li>e(x)   Exponencial de x.</li>
<li>j(n,x) Función de Bessel de orden n en x.</li>
</ul>

<h2 id="s2">2. Definición de funciones</h2>

<p>El lector habrá notado, quizás, que no se mencionó la función
tangente entre las de la librería matemática de <strong>bc</strong>. Esto se debe,
simplemente, a que <strong>bc</strong> no incluye esta función por defecto. Sin
embargo, esto es muy fácil de remediar con conocimientos básicos
de trigonometría. En efecto, podríamos calcular la tangente de
π/4 radianes de la siguiente manera.</p>

<pre class="terminal">    &gt; bc -l
    pi = 3.1415927;
    s(pi/4)/c(pi/4);
    1.00000002320510365001
    quit
</pre>

<p>El resultado no es exactamente 1 debido a que sólo hemos utilizado
siete decimales en la expresión de π.</p>

  <p>Supongamos que queremos calcular la tangente de muchos ángulos
diferentes. En este caso, sería mucho más sencillo tener una
función tangente (t(x), por ejemplo) en lugar de tener que invocar
el cociente entre el seno y el coseno. Podemos definir esta
función de la manera siguiente:</p>

<pre class="terminal">    &gt; bc -l
    pi=3.1415927;
    define t(x) {return s(x)/c(x);}
    t(pi/4);
    1.00000002320510365001
    t(pi/6);
    .57735027950300509089
</pre>

<p>Hemos creado la función t(x) con la instrucción define. Entre
llaves, explicamos el efecto de la función, que toma un valor
(representado por x) y devuelve el seno de este valor dividido
por su coseno (s(x)/c(x)). Algunas versiones de bc pueden
exigir que lo que sigue al return vaya entre paréntesis.</p>

  <p>Evidentemente, sería mucho más cómodo poder definir la función
tangente de una vez por todas. ¿Y por qué limitarnos a la función
tangente y no incluir también el valor de otras funciones, como
la secante, o incluso el valor de π? Para ello, escribimos en un
archivo de texto las instrucciones siguientes:</p>

<pre>    pi=3.1415927;

    define t(x) {
      return s(x)/c(x);
    }

    define sec(x)  {
      return 1/c(x);
    }

    define cosec(x)  {
      return 1/s(x);
    }

    define cotan(x)  {
      return c(x)/s(x);
    }
</pre>

<p>Podemos guardar las líneas precedentes en "trigonometria.bc".
Ya no es necesario incluir la definición de una función en una
sola línea, y esto hace más legibles nuestros cálculos.</p>

  <p>Cuando queramos utilizar nuestras definiciones, basta con
incluir el nombre de nuestro archivo al invocar <strong>bc</strong>. Es importante
recordar que si estamos ejecutando <strong>bc</strong> desde un directorio
diferente del que contiene nuestro archivo, es necesario incluir
también la ruta hasta el archivo.</p>

<pre class="terminal">    &gt; bc -l trigonometria.bc
    cosec(pi/6);
    1.99999997320505505194
</pre>

<h2 id="s3">3. Creación de scripts</h2>

<p>
Hasta ahora, hemos visto cómo definir funciones que utilizaremos
más adelante en nuestros cálculos, pero siempre hemos sido
nosotros quienes debíamos indicar la operación a llevar a cabo.
Esto no es una exigencia de <strong>bc</strong>. No hay ningún problema si
también queremos incluir cálculos definidos de antemano en
nuestros ficheros.
</p>

<p>
  Supongamos que necesitamos los cien primeros decimales del
número π. Como sabemos que tg(π/4) = 1, podemos deducir que
π = 4 arctg(1). Recuérdese que la función arctg(x) se expresa
en <strong>bc</strong> como a(x).
</p>

<p>En el fichero pi.bc podríamos escribir esto:</p>

<pre>    /* Los cien primeros decimales de pi */

    scale = 100;
    print "Cálculo de pi hasta el centésimo decimal:\n";
    print 4*a(1);
    print "\n";
    quit;
</pre>

<p>La expresión entre los signos /* y */ es un comentario, y <strong>bc</strong>
se lo salta al interpretar nuestras instrucciones. Los
comentarios se incluyen para que el código sea más
legible, no sólo por otros programadores, sino también para
uno mismo. Un programa complejo sin comentarios se vuelve
completamente ilegible en cuanto uno lo ha dejado de lado
durante una temporada.
</p>

<p>
Volvamos a nuestro código. La instrucción scale indica que
realizaremos cálculos de cien decimales. Print muestra un
mensaje en pantalla. El signo "\n" indica un retorno, es
decir, el texto pasa a la siguiente línea, y "quit" sale del
programa. La instrucción "print 4*a(1);" muestra en pantalla
el cálculo deseado. Como la función arco tangente viene
incluída en la librería matemática, es necesario ejecutar el
programa con la opción "-l".
</p>

<pre class="terminal">    &gt; bc -l pi.bc
    Cálculo de pi hasta el centésimo decimal:
    3.141592653589793238462643383279502884197\
    16939937510582097494459230781640628620899\
    86280348253421170676
</pre>

<h3 id="s3.1">3.1 Condiciones</h3>

<p>
Vamos a definir una función que calcule el factorial de un
número. El lector recordará que n! (factorial de n, siendo
n un número natural) se define como
</p>

<p class="formula">n! = n·(n-1)!</p>

<p class="continue">
Es decir, el factorial de un número es igual a este número
multiplicado por el factorial de este número menos uno.
Esto es un ejemplo típico de definición recursiva (es decir,
que incluye el mismo término a definir). Si definimos 0! = 1
(para garantizar que el cálculo finalice en algún momento),
podemos definir el factorial en bc como sigue:
</p>

<pre>    /* Factorial de un número natural*/

    scale = 0;

    define factorial(n) {
      if(n &lt; 0)
       print "Error: Factorial de un número negativo no definido.\n";
      if(n == 0)
       return 1;
      if(n &gt; 0)
       return n*factorial(n-1);
    }
</pre>

<p>
Este código incluye varias condiciones. Si n es negativo,
entonces se muestra un mensaje de error. En el caso de que n sea
igual a cero, la función devuelve 1. Para números naturales
positivos, utilizamos la definición recursiva.
</p>

<p>
  Nótese que se utilizan dos signos de igual para expresar la
igualdad entre n y cero. El operador = se conoce como operador
de asignación (asigna a una variable un valor). Por ejemplo,
"x = 3" asigna a la variable "x" el valor 3. "x == 3" devuelve
1 (verdadero) si "x" es efectivamente igual a 3 y 0 (falso) en
caso contrario.
</p>

<pre class="terminal">    &gt; bc
    a = 3;
    a == 3;
    1
    a = 2;
    a == 3;
    0
</pre>

<p>
Supongamos que el código definido más arriba se ha incluido
en el fichero factorial.bc:
</p>

<pre class="terminal">    &gt; bc -l factorial.bc
    factorial(5);
    120
    factorial(-2);
    Error: Factorial de un número negativo no definido.
    factorial(120);
    66895029134491270575881180540903725867527463331380\
    29810295671352301633557244962989366874165271984981\
    30815763789321409055253440858940812185989848111438\
    9650005964960521256960000000000000000000000000000
</pre>

<h3 id="s3.2">3.2 Bucles</h3>

<h4 id="s3.2.1">3.2.1 for</h4>

<p>
También podríamos haber definido la función factorial mediante
un bucle. n! es el producto desde 1 hasta n.
</p>

<p class="formula">n! = 1·2···(n-1)·n</p>

<p>
En código:
</p>

<pre>    /*  Función factorial (con bucle for) */

    scale = 0;

    define factorial (n) {
      resultado = 1;
      for(i = 1; i &lt;= n; i++)
        resultado *= i;
      return resultado;
    }
</pre>

<p>
Este algoritmo es más lento que el recursivo.
</p>

<p>
  Los resultados parciales se guardan en la variable resultado
(que empieza valiendo 1). La instrucción for funciona así:
</p>

<pre>    for(&lt;<em>inicialización</em>&gt;;&lt;<em>condición</em>&gt;;&lt;<em>actualización</em>&gt;)
</pre>

<p>
La inicialización es una instrucción que se ejecuta antes de
que comience el bucle. En nuestro caso, se asigna el valor 1 a
la variable i. La condición se evalúa en cada repetición. Si
la condición se cumple (aquí, que i es menor o igual que n)
entonces se vuelve a ejecutar la instrucción que sigue al for.
La actualización se ejecuta después de cada repetición. La
actualización que usamos aquí es i++, que es una manera de
aumentar i en una unidad. Es decir, i++ es equivalente a
i = i + 1. En cada iteración (repetición), se ejecuta el comando
</p>

<pre>    resultado *= i;
</pre>

<p>
que es otra forma de escribir
</p>

<pre>    resultado = resultado * i;
</pre>

<p>
Finalmente, se devuelve la variable resultado.
</p>

<h4 id="s3.2.2">3.2.2 while</h4>

<p>
Otra opción para programar bucles es utilizar un bucle while.
Veamos un ejemplo.
</p>

<pre>    /*  Función factorial (bucle while)  */

    scale = 0;

    define factorial(n) {
      i = 1;
      resultado = 1;
      while (i &lt;= n)
      {
        resultado *= i;
        i++;
      }
      return resultado;
    }
</pre>

<p>
Este algoritmo es sólo ilustrativo. Desde el punto de vista del
cálculo de un factorial no es demasiado bueno.
</p>

<p>
  Este programa también incluye la utilización de las llaves
para agrupar instrucciones. A continuación de la instrucción
while hay un bloque de instrucciones entre llaves. El comando
while se aplica al bloque entero.
</p>

<h4 id="s3.2.3">3.2.3 Advertencia</h4>

<p>
Con los bucles siempre hay que asegurarse de que la condición de
salida del bucle se cumplirá en algún momento. De otra forma,
entraremos en un bucle infinito. Por ejemplo, la siguiente
función se ejecuta indefinidamente.
</p>

<pre>    /*  Bucle infinito  */

    define bucleinfinito(x) {
      while(1&lt;2)
      {
        print x++;
        print ": ¡Socorro! Estoy en un bucle infinito.\n";
      }
    }
</pre>

<p>
Para salir de un bucle infinito mientras se está ejecutando
pulsa CTRL+C.
</p>

<h3 id="s3.3">3.3 Matrices</h3>

<p>
<strong>bc</strong> permite definir matrices de una dimensión. El índice de cada
elemento se encierra entre paréntesis. Podemos definir el vector
v = (1, -1, 2) y calcular su módulo así:
</p>

<pre>    scale = 5;
    v[1] = 1 ; v[2] = -1; v[3] = 2;
    sqrt(v[1]^2 + v[2]^2 + v[3]^2);
    2.44948
</pre>

<p>
Una función puede aceptar una matriz como argumento. Veremos
un ejemplo en el que definimos el sumatorio de los n primeros
elementos almacenados en una matriz.
</p>

<pre>    define sumatorio(x[], n) {
    suma = 0;
    for(i = 1; i &lt;= n; i++)
      suma += x[i];
    return suma;
    }
</pre>

<p>
Los corchetes en x[] indican que la variable x es una matriz.
suma += x[i] es equivalente a escribir suma = suma + x[i].
Nótese que se recorren los índices de la matriz x con la
variable i (que cambia en cada iteración del bucle). Sigue
un ejemplo de utilización de la función sumatorio.
</p>

<pre class="terminal">    u[1] = 1; u[2] = 5; u[3] = 7; u[4] = 5;
    sumatorio(u[], 4);
    18
    sumatorio(u[], 2);
    6
</pre>

<h3 id="s3.4">3.4 Variables auto</h3>

<p>
Supongamos que tenemos una función <strong>contar(n)</strong> que muestra en
pantalla los números desde 1 hasta n.
</p>

<pre>    define contar(n) {
      for(i = 0; i &lt;= n; i++)
        print i, " ";
      print "\n";
    }
</pre>

<p>
Esta función no devuelve explícitamente ningún valor (nótese la
ausencia de la instrucción <strong>return</strong>). <strong>bc</strong> presupone en estos casos
que el valor devuelto es cero. Al invocar la rutina, se mostrará
este valor nulo en la pantalla.
</p>

<pre class="terminal">    contar(5);
    1 2 3 4 5
    0
</pre>

<p>
Para evitar este cero no deseado, podemos asignar el valor
devuelto a una variable. <strong>bc</strong> permite asignar
valores al punto (.), que no suele usarse como nombre de
variable.
</p>

<pre class="terminal">   . = contar(5);
   1 2 3 4 5
</pre>

<p>
Imaginemos que queremos utilizar nuestra función para mostrar
números dispuestos así:
</p>

<pre class="terminal">    1
    1 2
    1 2 3
    1 2 3 4
    1 2 3 4 5
</pre>

<p>
Si escribimos esto,
</p>

<pre>    for(i = 0; i &lt;= 5; i++)
      . = contar(i);
</pre>

<p class="continue">
obtenemos el resultado siguiente:
</p>

<pre class="terminal">    1
    1 2 3
    1 2 3 4 5
</pre>

<p>
¿Dónde están las dos líneas que faltan? El problema aquí es que
la función <strong>contar(n)</strong> también cambia el valor de la variable i.
</p>

<p>
  La solución, dirá el lector, es utilizar una variable distinta
para cada bucle. Y tiene razón, pero hay un problema. Puede que
<strong>contar(n)</strong> la haya escrito una persona y que la esté utilizando
otra, que no tiene por qué saber los nombres de las variables
que usa esta función. Para usarla, debería bastar con saber qué
hace, sin tener que consultar cómo lo hace. <strong>bc</strong> permite usar la
instrucción <strong>auto</strong> para especificar que una variable es propia de
una función.
</p>

<pre>    define contar(n) {
    auto i;
      for(i = 0; i &lt;= n; i++)
        print i, " ";
      print "\n";
    }
</pre>

<p>
De este modo, <strong>bc</strong> sabe que la "i" utilizada dentro de <strong>contar</strong> es
diferente de cualquier otra que se haya podido utilizar en el
programa.
</p>

<p>
  Este bloque termina con una advertencia importante. Si la
función <strong>contar</strong> invocara a otra función que utilizara la variable
i (y que no tuviera instrucción <strong>auto</strong>), entonces la variable
modificada sería la de <strong>contar(n)</strong>, y no la de otras partes del
programa. Es decir, las variables auto forman una jerarquía. Si
en una función f no se declara que una variable es auto,
entonces la variable a la que nos referimos es la de la función
que invocó a f (que a su vez puede ser la de la función que
invocó a esta, y así sucesivamente hasta que encontremos una
declaración auto, o ninguna, en caso de que siempre nos estemos
refiriendo a la misma variable).
</p>

<h3 id="s3.5">3.5 Instrucción read()</h3>

<p>
En algunas ocasiones, puede resultar conveniente que ciertos
datos se introduzcan durante la ejecución de la función. Para 
ello, se utiliza la instrucción <strong>read()</strong>.
</p>

<pre>    define pi() {
      auto s, n, pi;
      s = scale;    
      print "Decimales de pi:\n";
      n = read();
      scale = n; 
      pi = 4*a(1);
      scale = s;  
      return pi;
    }
</pre>

<p>
Al invocar la función <strong>pi()</strong> obtenemos lo siguiente (los 
valores
10 y 20 los introduce el usuario):
</p>

<pre class="terminal">    pi();
    Decimales de pi:
    10
    3.1415926532 
    pi();
    Decimales de pi:
    20
    3.14159265358979323844
</pre>

<h3 id="s3.6">3.6 Pasar matrices por referencia</h3>

<p>
Puede que necesites que una función cambie el valor de uno de
sus argumentos. Por ejemplo, si tenemos una matriz que guarda
los datos de una hora (horas, minutos y segundos) y queremos
añadir h horas, m minutos y s segundos, podemos usar la función
siguiente:
</p>

<pre>   define sumahoras(*hora[], h, m, s) {
   s = scale;
   scale = 0;

   hora[1] = hora[1] + h + (hora[2] + m)/60 + (hora[3] + s)/3600;
   hora[2] = (hora[2] + m + (hora[3] + s)/60)%60;
   hora[3] = (hora[3] + s)%60;

   scale = s;
   }
</pre>

<p>
El asterisco delante de la matriz hora[] en la primera línea de
la definición indica que la matriz se pasa por referencia. Si no
se incluye este asterisco, la función no modifica la matriz hora[],
sino una copia local de estas variables.
</p>

<p>
El resultado es éste:
</p>

<pre class="terminal">   /* Hora original: 1:20:45 */
   mihora[1] = 1; mihora[2] = 20; mihora[3] = 45;

   /* Suma 2 horas, 45 minutos y 20 segundos */
   . = sumahoras(mihora[], 2, 45, 20);

   /* Resultado */
   print mihora[1], ":", mihora[2], ":", mihora[3], "\n";
   4:6:5
</pre>

<p>
Si no hubiéramos pasado la matriz <strong>mihora[]</strong>
por referencia, nos habríamos encontrado que el resultado
era <strong>1:20:45</strong>.
</p>

<h2 id="s4">4. Ejemplos</h2>

<p>
El código de los ejemplos que siguen debería poder consultarse
en mi espacio gopher, junto a este archivo.
</p>

<p>
(<a href="gopher://sdf.lonestar.org/1/users/marcmmw/esp/programacion">gopher://sdf.lonestar.org/1/users/marcmmw/esp/programacion</a>)
</p>

<p>
En esta versión (html), he incluído un enlace directo a cada uno de los ficheros.
Los usuarios de Firefox deberían poder acceder sin
problemas utilizando el complemento
<a href="http://gopher.floodgap.com/overbite/">Overbite</a>.
Los usuarios de Internet explorer pueden descargar
Firefox gratuitamente en
<a href="http://www.mozilla-europe.org/es/firefox/">la página oficial de firefox</a>.
</p>

<h3 id="s4.1">4.1 Matemáticas</h3>

<p>
En los siguientes ejemplos, se comentan sólo fragmentos de
código. Con el signo [...] se indica la omisión de alguna
parte del programa.
</p>

<h4 id="s4.1.1">4.1.1 Teoría de números
(<a href="gopher://sdf.lonestar.org/0/users/marcmmw/esp/programacion/bc/numeros.bc">numeros.bc</a>)</h4>

<p>
Nuestro ejemplo incluye un algoritmo para encontrar los factores
primos de un número natural n. No es el algoritmo más eficiente,
pero es uno de los más sencillos de comprender.
</p>

<p>
  Para cada número i menor que n, comprobamos si n es divisible
entre i, es decir, si el resto de n entre i es cero. Si es así,
realizamos la división y factorizamos el cociente. Con este
método, sólo es necesario que i recorra los números desde 2
hasta la raíz cuadrada de n (el lector puede entretenerse en
demostrar esto).
</p>

<pre>    /* Factores primos */

    define factores(n) {

      [...]

      if(n &gt;= 2)
      {

        m = n;
        i = 2;

        while(i &lt;= sqrt(n))
        {
          if((m % i) == 0)
          {
            [...]
            print  i;
            m = m / i;
            i = i - 1;
          }
          i = i + 1;
        }
      }
      [...]
    }
</pre>

<p>
El fichero contiene también funciones que calculan los
n-ésimos números de Mersenne y de Fermat.
</p>

<pre class="terminal">    &gt; bc -l numeros.bc
    factores(1254);
    2, 3, 11, 19.
    1254
    mersenne(12);
    4095
    fermat(5);
    65537
    factores(fermat(4));
    65537.
    65537
    factores(mersenne(12));
    3, 3, 5, 7, 13.
    4095
</pre>

<p>
También se puede utilizar la función <strong>comb(n,m)</strong> para calcular
números combinatorios (coeficientes binomiales). El triángulo de
Tartaglia (también conocido como triángulo de Pascal) se
consigue ordenando los coeficientes binomiales por filas, de
modo que cada número es igual a la suma de los dos números
más cercanos en la fila inmediatamente superior.
</p>

<pre>       1 1
      1 2 1
     1 3 3 1
    1 4 6 4 1
       etc.
</pre>

<p>
Mediante <strong>comb(n,m)</strong> es muy sencillo calcular los 
coeficientes
del triángulo por filas, como veremos a continuación. Mediante
un bucle (en i) se recorren las filas del triángulo. En cada
iteración de este bucle, se ejecuta otro bucle (en j) que
comienza en 0 y acaba en el valor que toma i en la iteración,
para recorrer todos los elementos de la fila. Se muestra cada
elemento en pantalla (separándolo del anterior con un espacio).
Nótese que antes se ha introducido un bucle en j para imprimir
un número adecuado de espacios antes de los elementos de una
fila para crear el hueco a la izquierda del triángulo.
</p>

<pre class="terminal">    &gt; bc -l probabilidad.bc
    scale = 0;
    for(i = 1; i &lt;= 9; i++)
    {
      /* Deja hueco a la izquierda de la fila */
      for(j = 1; j &lt;= 9 - i; j++)
        print " ";
      /* Muestra en pantalla los coeficientes */
      for(j = 0; j &lt;= i; j++)
        print comb(i,j), " ";
      /* Pasa a la línea siguiente */
      print "\n";
    }
            1 1
           1 2 1
          1 3 3 1
         1 4 6 4 1
        1 5 10 10 5 1
       1 6 15 20 15 6 1
      1 7 21 35 35 21 7 1
     1 8 28 56 70 56 28 8 1
    1 9 36 84 126 126 84 36 9 1
</pre>

<p>
El cálculo está resuelto, pero la alineación todavía no es
perfecta. El lector ambicioso querrá, quizás, ensayar
soluciones más sofisticadas.
</p>

<p>
  Leo en la wikipedia que si se marcan los números impares del
triángulo de Tartaglia, se obtiene una figura parecida al triángulo
de Sierpinski. Vamos a comprobarlo cambiando el segundo bucle en j
del código anterior por las líneas siguientes.
</p>

<pre>      for(j = 0; j &lt;= i; j++)
      {
        if(comb(i,j)%2==1) print "X ";
        if(comb(i,j)%2==0) print "  ";
      }
</pre>

<p>
En la prueba que hice yo, dibujé las primeras quince filas (en lugar de 
nueve) y empecé en i = 0. El resultado es un dibujo como el que se 
muestra a continuación. 
</p>

<pre class="terminal">                   X
                  X X
                 X   X
                X X X X
               X       X
              X X     X X
             X   X   X   X
            X X X X X X X X
           X               X
          X X             X X
         X   X           X   X
        X X X X         X X X X
       X       X       X       X
      X X     X X     X X     X X
     X   X   X   X   X   X   X   X
    X X X X X X X X X X X X X X X X
</pre>

<p>
Con más líneas el parecido es todavía más evidente.
</p>

<h4 id="s4.1.2">4.1.2 Probabilidad y estadística (<a href="gopher://sdf.lonestar.org/0/users/marcmmw/esp/programacion/bc/probabilidad.bc">probabilidad.bc</a>)</h4>

<p>
Las funciones de densidad de probabilidad dependen de la
librería matemática.
</p>

<p>
  En probabilidad.bc se definen funciones para calcular la
media aritmética y la desviación estándar de n datos almacenados
en una matriz.
</p>

<pre class="terminal">    &gt; bc -l probabilidad.bc
    scale = 2;
    x[1] = 2; x[2] = 4; x[3] = 4; x[4] = 4;
    x[5] = 5; x[6] = 5; x[7] = 7; x[8] = 9;
    media(x[], 8);
    5.00
    desv(x[], 8);
    2.00
</pre>

<p>
  ¿Qué más incluye el fichero probabilidad.bc? Además de las
funciones factorial y <strong>comb(n,m)</strong>, se encuentran definidas las
funciones binomial, normal y de Poisson utilizadas en probabilidad
y estadística.
</p>

<div class="floatright"><img src="C%C3%A1lculo%20num%C3%A9rico%20con%20bc_files/bc_003.png" alt="Distribución normal 
con mu = 0 y sigma = 1.">
<p class="caption"> <strong>Figura 1:</strong> Distribución normal con μ = 0 y σ = 1.</p>
</div>

<p>
Con la función <strong>norm(x, mu, sigma)</strong> se obtuvieron los datos para
crear la gráfica de la función normal con mu = 0 y sigma = 1 (ver
figura 1).
</p>

<p>
Para crear un gráfico como este es necesario, en primer lugar,
calcular los datos (en nuestro caso, con <strong>bc</strong>). A continuación se
utiliza un programa de dibujo (la figura 1 se creó con <strong>graph</strong>,
incluido en los plotutils).
</p>

<p>
  Para el primer paso, se calculan los valores de muchas parejas
de valores (x, f(x)). Por ejemplo, se pueden escribir las
siguientes líneas en un fichero normal.bc:
</p>

<pre>    scale = 10;

    for(x = -2; x &lt;= 2; x += 0.05)
      print x, "   ", norm(x,0,1), "\n";

    quit
</pre>

<p>
  La rutina anterior calcula el valor de la función <strong>norm</strong> para
valores de x entre -2 y 2 separados por intervalos de 0.05.
Ejecutando esta rutina junto con el contenido de probabilidad.bc
obtenemos los datos.
</p>

<pre class="terminal">    &gt; bc -l probabilidad.bc normal.bc
    -2   .0539909664
    -1.95   .0595947060
    -1.90   .0656158147

        [...]

    1.90   .0656158147
    1.95   .0595947060
    2.00   .0539909664
</pre>

<p>
Se podrían copiar todos estos datos a mano, o cortando y pegando,
pero es mucho más cómodo redirigirlos a un fichero (aquí
normal.dat) directamente desde la línea de comandos así:
</p>

<pre class="terminal">    &gt; bc -l probabilidad.bc normal.bc &gt; normal.dat
</pre>

<p>
En lugar de mostrar los datos en pantalla, la instrucción
"&gt; normal.dat" indica que los datos deben guardarse en el
fichero nombrado.
</p>

<p>
  Ahora queremos crear una imagen a partir de estos datos
con el programa graph.
</p>

<pre class="terminal">    &gt; graph -T gif -y 0 1 normal.dat &gt; normal.gif
</pre>

<p>
Con "-T gif" se especifica el formato de la imagen. "-y 0 1"
indica el rango de valores del eje y. Si se instala plotutils,
se suelen instalar también las páginas de manual
correspondientes, por lo que pueden consultarse ahí más
opciones del comando graph. La página del manual se invoca
así:
</p>

<pre class="terminal">    &gt; man graph
</pre>

<p>
Pueden conseguirse los mismos resultados de manera más
sencilla con programas como <strong>gnuplot</strong>, pero uno de los objetivos
de este artículo es el de mostrar cómo se pueden realizar
cálculos relativamente sofisticados con recursos muy
limitados.
</p>

<h4 id="s4.1.3">4.1.3 Cálculo (<a href="gopher://sdf.lonestar.org/0/users/marcmmw/esp/programacion/bc/calculo.bc">calculo.bc</a>)</h4>

<p>
Este apartado está dedicado a la derivación e integración
numérica, pero comentaremos antes el cálculo numérico de
límites. En los casos en los que no existe indeterminación,
basta con sustituir el valor correspondiente. Para calcular
el límite
</p>

<pre>               sin(x)
    lim        -------
       x -&gt; 2  2 Ln(x)
</pre>

<p class="continue">
no hay más que escribir
</p>

<pre class="terminal">    &gt; bc -l
    s(2)/(2*l(2))
</pre>

<p>
El problema surge con los límites en el infinito y las
indeterminaciones. Veamos el límite de sin(x)/x en x = 0.
</p>

<pre class="terminal">    &gt; bc -l
    s(0)/0
    Runtime error (func=(main), adr=7): Divide by zero
</pre>

<p>
La idea intuitiva que hay detrás de la definición matemática
de límite de una función en un punto es ésta: a medida que
la variable se aproxima al punto considerado, el valor de la
función se aproxima inexorablemente al límite (si es que
existe). Por lo tanto, podemos examinar el comportamiento
de la función en las cercanías del punto.
</p>

<pre class="terminal">    &gt; bc -l
    s(0.1)/0.1
    .99833416646828152300
    s(0.01)/0.01
    .99998333341666646800
    s(0.001)/0.001
    .99999983333334166000
</pre>

<p>
El límite en este caso parece ser igual a uno (y, de hecho,
lo es).
</p>

<p>
  Para los límites en el infinito, podemos utilizar valores
grandes en valor absoluto.
</p>

<pre class="terminal">    &gt; bc -l
    e(-10)
    .00004539992976248485
    e(-20)
    .00000000206115362243
    e(-50)
    0
</pre>

<p>
Evidentemente, lo que cuenta como número "grande" depende
del contexto.
</p>

<p>
  En cualquier caso, podríamos preguntar qué garantía
tenemos de que la función vaya a respetar la tendencia
observada para entornos más reducidos (o números mayores).
La respuesta es que, sin una demostración rigurosa, no hay
garantía, y es importante tener en cuenta este hecho en
la derivación e integración numéricas (cuyas definiciones
están basadas, al fin y al cabo, en la de límite). El
lector puede entretenerse en intentar determinar (sin
éxito) el límite de sin(1/x) cuando x tiende a cero, por
el método indicado.
</p>

<p>
  Sin embargo, si las funciones tienen un comportamiento
suficientemente parecido al de una recta en los intervalos
considerados, es fácil definir una aproximación numérica
para sus derivadas e integrales. La definición de
derivada es:
</p>

<pre>                      f(a + h) - f(a)
    f'(a) = lim       ---------------
               h -&gt; 0        h
</pre>

<p>
Para conseguir una aproximación, bastará con calcular el
cociente sustituyendo h por un valor p suficientemente
pequeño. Por ejemplo, la derivada de sin(x) en x = 0 se
puede aproximar así:
</p>

<pre class="terminal">    &gt; bc -l
    (s(0 + 0.01) - s(0))/0.01
    .99998333341666646800
</pre>

<p>
Como siempre, nos gustaría tener una función que tome la
función a derivar, el punto, y el paso p. Pero en bc no se
pueden pasar las funciones como parámetros, es decir, no
se puede definir una función <strong>derivada(f(x), x, p)</strong>, siendo
f otra función. Afortunadamente, podemos resolver este
problema dando un pequeño rodeo.
</p>

<pre>    define derivada(a,p) {
      return (f(a+p) - f(a))/p;
    }
</pre>

<p>
En calculo.bc la función <strong>derivada</strong> asume que la función a
derivar se llama f(x), por lo que sólo hay que definirla
antes de invocar la rutina.
</p>

<pre class="terminal">    &gt; bc -l calculo.bc
    pi = 3.1415927;
    /*  Ahora la función a derivar es sin(x)  */
    define f(x) { return s(x);}
    derivada(pi/6,0.0001);
    .8660010000
    /*  Ahora la función a derivar es cos(x)  */
    define f(x) { return c(x);}
    derivada(pi/6,0.0001);
    -.5000430000
</pre>

<div class="floatcentre"><img src="C%C3%A1lculo%20num%C3%A9rico%20con%20bc_files/bc_004.png" alt="Función de Bessel de orden 3 y su derivada.">
<p class="centrecaption"> <strong>Figura 2:</strong> Función de Bessel de orden 3 (en rojo) y su derivada (en azul). Datos calculados con <strong>bc</strong> y dibujados con <strong>graph</strong>.</p>
</div>

<p>
En nuestro fichero hemos incluido también la derivada
enésima por medio de una definición recursiva.
</p>

<p>
  Podemos utilizar nuestra rutina para calcular derivadas
laterales, lo cual es especialmente útil en funciones
definidas por intervalos.
</p>

<pre class="terminal">    &gt; bc -l calculo.bc
    define f(x) {
      if(x &lt;= 0) return x^2;
      if(x &gt; 0) return x;
    }

    /* Derivada de f(x) en cero por la derecha */
    derivada(0, 0.001);
    1.0000000000
    /* Derivada de f(x) en cero por la izquierda */
    derivada(0, -0.001);
    -.0010000000
</pre>

<p>
Para calcular las integrales, utilizaremos la definición
de Riemann.
</p>

<pre>    / b                     __ N
    |  f(x) dx = lim        &gt;       f(x ) h
    / a             h -&gt; 0  ~~i = 0    i
</pre>

<p>
Donde N = (a + b)/h. De nuevo, aproximamos el límite
sustituyendo h por un valor pequeño p y obteniendo un
sumatorio finito.
</p>

<pre>    define integral(a, b, p) {
      integ = 0;
      for(x = a; x &lt; b; x += p)
        integ += f(x)*p;
      return integ;
    }
</pre>

<p>
Para calcular la integral definida de la función cos(x)
entre π/2 y π:
</p>

<pre class="terminal">    &gt; bc -l calculo.bc
    pi = 3.1415927;
    define f(x) { return c(x);}
    integral(pi/2, pi, 0.01);
    -1.0041953600
</pre>

<p>
Para conseguir una aproximación mayor se puede utilizar un paso
menor, pero hay ocasiones en que es conveniente utilizar un
número más reducido de pasos (por ejemplo, cuando el tiempo
que lleva evaluar la función f(x) es elevado). Nuestra
aproximación medía el área bajo la curva f(x) con rectángulos,
pero podemos cambiar el borde superior de nuestros rectángulos
para que se ajuste más a la curva f(x) como, por ejemplo, si
utilizamos una recta desde el punto (x, f(x)) al punto (x + h,
f(x + h)). Hemos introducido una aproximación todavía mejor
mediante tramos parabólicos atribuida a Thomas Simpson.
</p>

<pre class="terminal">    &gt; bc -l calculo.bc
    scale = 20;
    pi = 4*a(1);
    define f(x) { return s(x);}
    integral(0, 2*pi, 0.1);
    -.00069944923028496906
    simpson(0, 2*pi, 0.1);
    .00014136362149477784
</pre>

<h4 id="s4.1.4">4.1.4 Números complejos (<a href="gopher://sdf.lonestar.org/0/users/marcmmw/esp/programacion/bc/complejos.bc">complejos.bc</a>)</h4>

<div class="floatright"><img src="C%C3%A1lculo%20num%C3%A9rico%20con%20bc_files/bc_002.png" alt="Fractal de 
Mandelbrot.">
<p class="caption"> <strong>Figura 3:</strong> Fractal de Mandelbrot y 
detalle del mismo (derecha).<br>Los cálculos se realizaron en 
<strong>bc</strong> con las rutinas de complejos.bc.</p>
</div>

<p>
En este apartado se ponen de manifiesto algunas de las
limitaciones de bc. Las funciones no pueden devolver matrices
(es decir, no es válida la instrucción <strong>return z[];</strong>), así que
hay que buscar algún sistema alternativo.
</p>

<p>
  Representaremos los números complejos con una matriz de dos
elementos, de modo que si z = a + bi, usaremos las asignaciones 
siguientes:
</p>

<pre>    z[0] = a;
    z[1] = b;
</pre>

<p>
Algunas funciones devuelven un número real (parte real, parte
imaginaria, módulo y argumento), mientras que otras deberían
devolver un número complejo (exponencial de un número complejo,
por ejemplo). En estos últimos casos, pasaremos por referencia
la matriz donde queremos que se almacene la acción de la función,
mientras que la función devolverá el valor cero.
</p>

<p>
  En nuestro ejemplo, definiremos dos números complejos
z<sub>1</sub> = 3 + 2i, y z<sub>2</sub> = -1 + i. Podemos mostrarlos en 
forma de binomio con la rutina <strong>printz(z[])</strong>. 
</p>

<pre class="terminal">    z1[0] = 3; z1[1] = 2;
    z2[0] = -1; z2[1] = 1;
    . = printz(z1[]);
    3 + 2i
    . = printz(z2[]);
    -1 + 1i
</pre>

<p>
Asignamos el valor de la función print z a la variable "." para
evitar que se muestre en pantalla un cero adicional (ver sección
3.4). A continuación, Al sumar, restar, multiplicar o dividir
z<sub>1</sub> y z<sub>2</sub>, guardamos el resultado la variable
<strong>zres[]</strong>.
</p>

<pre class="terminal">    . = sumaz(z1[], z2[], zres[]); . = printz(zres[]);
    2 + 3i
    . = restaz(z1[], z2[], zres[]); . = printz(zres[]);
    4 + 1i
    . = prodz(z1[], z2[], zres[]); . = printz(zres[]);
    -5 + 1i
    scale = 2;
    . = divz(z1[], z2[], zres[]); . = printz(zres[]);
    -0.50 + -2.50i
</pre>

<p>
Podemos calcular la parte real, imaginaria, módulo y argumento.
La función <strong>printzt(z[])</strong> escribe z en forma trigonométrica.
</p>

<pre class="terminal">    rez(z1[]);
    3
    imz(z1[]);
    2
    modz(z1[]);
    3.60
    argz(z1[]);
    .58
    . = printzt(z1[]);
    3.60 * (cos(.58) + i sin(.58))
</pre>

<p>
Las potencias en bc sólo aceptan exponentes enteros, así que he
definido una función <strong>pot(x, y)</strong> para exponentes reales arbitrarios. 
Utilizando esta expresión, he escrito otra llamada <strong>potz</strong> que
calcula el resultado de elevar un número complejo a un número
real arbitrario. <strong>pot(x,y)</strong> utiliza el operador <strong>^</strong> cuando <em>y</em> es entero,
y la expresión
</p>

<p class="formula">
    x<sup>y</sup> = e<sup>y Ln(x)</sup>
</p>

<p class="continue">
para cualquier otro número real.
</p>

<pre class="terminal">    scale = 5;
    /*  Cálculo de 3^2.1  */
    pot(3,2.1);
    10.04505
    /*  Cálculo de z1^2.1  */
    . = potz(z1[], 2.1, zres[]); . = printz(zres[]);
    4.87294 + 13.95202i
</pre>

<p>
Se puede calcular una raíz de orden n utilizando potz para hallar
la potencia 1/n. El resto de las raíces se pueden ir calculando
multiplicando este resultado por <em>e<sup>2πki/n</sup></em>, con <em>k</em> = 1, 2,
..., <em>n</em> - 1. La función <strong>raices(z[],n)</strong> muestra <em>n</em> raíces de z[].
</p>

<pre class="terminal">    z[0] = 1; z[1] = 0;
    /*  Raíz octava de 1  */
    . = potz(z[], 1/8, zres[]); . = printz(z[]);
    1 + 0i
    /*  Ocho raíces octavas de 1  */
    . = raicesz(z[], 8);
    1.00000 + 0i
    .70711 + .70710i
    0 + 1.00000i
    -.70710 + .70710i
    -.99999 + 0i
    -.70710 + -.70710i
    0 + -1.00000i
    .70710 + -.70711i
</pre>

<p>
El fichero incluye también funciones para calcular exponenciales,
senos, cosenos y logaritmos de números complejos. Como el
logaritmo es una función multivaluada, <strong>logz(z[], zres[])</strong> almacena en
<strong>zres[]</strong> solamente uno de los valores posibles. Los demás pueden
hallarse sumando 2πki a este valor (donde k es un número
entero). Por último, la función <strong>potzz(z1[],z2[], zres[])</strong> calcula el
resultado de z<sub>1</sub><sup>z<sub>2</sub></sup>.
</p>

<pre class="terminal">    . = expz(z1[], zres[]); . = printz(zres[]);
    -8.35839 + 18.26357i
    . = sinz(z1[], zres[]); . = printz(zres[]);
    .53087 + -3.59055i
    . = cosz(z1[], zres[]); . = printz(zres[]);
    -3.72452 + -.51178i
    . = logz(z1[], zres[]); . = printz(zres[]);
    1.28247 + .58799i
    . = potzz(z1[], z2[], zres[]); . = printz(zres[]);
    .22950 + 3.65836i
</pre>

<h4 id="s4.1.5">4.1.5 Vectores (<a href="gopher://sdf.lonestar.org/0/users/marcmmw/esp/programacion/bc/vectores.bc">vectores.bc</a>)</h4>

<p>
Utilizando ideas parecidas a las de la sección anterior, se
pueden definir las operaciones vectoriales. Las funciones que
devuelvan un vector almacenarán su resultado en la variable
<strong>vres[]</strong>. La función <strong>printv(v[])</strong> muestra el vector <strong>v[]</strong> con sus
coordenadas listadas entre paréntesis. Las funciones están
definidas para vectores tetradimensionales, pero se pueden
utilizar para vectores en dos y tres dimensiones dejando las
componentes adicionales iguales a cero:
</p>

<pre>    v[1] = 1; v[2] = -1;
</pre>

<p>
Con este comando se define el vector v = (1, -1). bc supone
automáticamente que <strong>v[0]</strong> y <strong>v[3]</strong> son nulos (siempre que no se les
haya asignado antes un valor diferente).
</p>

<p>
Definiremos los vectores v<sub>1</sub> = (0, 2, -1, 2), v<sub>2</sub> = 
(-1, 1, 0, 3) y v<sub>3</sub> = (0, 0, 2, -1).
</p>

<pre class="terminal">    v1[0] = 0; v1[1] = 2; v1[2] = -1; v1[3] = 2;
    v2[0] = -1; v2[1] = 1; v2[2] = 0; v2[3] = 3;
    v3[0] = 0; v3[1] = 0; v3[2] = 2; v3[3] = -1;
    . = printv(v1[]); . = printv(v2[]); . = printv(v3[]);
    (0, 2, -1, 2)
    (-1, 1, 0, 3)
    (0, 0, 2, -1)
</pre>

<p>
A continuación se muestran ejemplos de las operaciones de suma,
resta y producto por un escalar.
</p>

<pre class="terminal">    /* Suma de vectores */
    . = sumav(v1[], v2[], vres[]); . = printv(vres[]);
    (-1, 3, -1, 5)
    /* Resta de vectores */
    . = restav(v1[], v2[], vres[]); . = printv(vres[]);
    (1, 1, -1, -1)
    /* Producto por un escalar */
    . = prodv(3, v1[], vres[]); . = printv(vres[]);
    (0, 6, -3, 6)
</pre>

<p>
Sigue un ejemplo de los productos internos. El producto escalar
y el producto mixto devuelven un número real, por lo que no es
necesario consultar el valor de <strong>vres[]</strong> después de invocar estas
funciones. El producto vectorial y el producto mixto están
definidos para vectores tridimensionales, por lo que no entra en
el cálculo la primera componente de los vectores (la de índice 0).
</p>

<pre class="terminal">    /* Producto escalar */
    escalar(v1[], v2[]);
    8
    /* Producto vectorial (Para vectores tridimensionales) */
    . = vectorial(v1[], v3[], vres[]); . = printv(vres[]);
    (0, -3, 2, 4)
    /* Producto mixto (Para vectores tridimensionales) */
    mixto(v1[], vres[], v3[])
    -13
</pre>

<h3 id="s4.2">4.2 Física</h3>

<p>
Es relativamente común encontrarse en física con una ecuación
intratable desde el punto de vista analítico. En estos casos,
no queda más remedio que recurrir a una solución numérica.
</p>

<h4 id="s4.2.1">4.2.1 Dinámica de una partícula (<a href="gopher://sdf.lonestar.org/0/users/marcmmw/esp/programacion/bc/fuerzas.bc">fuerzas.bc</a>)</h4>

<p>
La idea básica para resolver las ecuaciones del movimiento
de una partícula sometida a fuerzas es sencilla. Se parte
de las ecuaciones de Newton,
</p>

<p class="formula">
    <strong>F</strong> = m · <strong>a</strong>,
</p>

<p class="continue">
y despejando la aceleración,
</p>

<p class="formula">
    <strong>a</strong> = <sup>d<sup>2</sup><strong>r</strong></sup>/<sub>dt<sup>2</sup></sub>
      = <sup><strong>F</strong></sup>/<sub>m</sub>.
</p>

<p>
Las derivadas se calculan de forma aproximada utilizando
incrementos temporales pequeños (en lugar de resolver el
límite de la definición).
</p>

<pre>    df            f(t + h) - f(t)  ~  f(t + dt) - f(t)
    -- = lim      ---------------  =  ----------------,
    dt      h -&gt; 0        h                 dt
</pre>

<p class="continue">
donde <em>dt</em> no es más que un paso temporal pequeño.
Despejando de la fórmula de la derivada, se encuentra que,
si conocemos las posiciones y velocidades iniciales y las
fuerzas, podemos calcular las posiciones y velocidades
nuevas después de un intervalo de tiempo <em>dt</em>.
</p>

<p class="formula">
<strong>v</strong><em class="paren">(</em>t
+ dt<em class="paren">)</em>
=<strong>v</strong><em class="paren">(</em>t<em class="paren">)</em>
+ <strong>a</strong><em class="paren">(</em>t<em class="paren">)</em>*dt,<br>

<strong>r</strong><em class="paren">(</em>t
+ dt<em class="paren">)</em> = 
<strong>r</strong><em class="paren">(</em>t<em class="paren">)</em>
+ <strong>v</strong><em class="paren">(</em>t<em class="paren">)</em>*dt,
</p>

<p>
Ahora, con las posiciones nuevas, se pueden calcular de
nuevo las fuerzas. Repitiendo este proceso, se puede
ir avanzando paso a paso en el tiempo calculando la
trayectoria de la partícula.
</p>

<div class="floatright"><img src="C%C3%A1lculo%20num%C3%A9rico%20con%20bc_files/bc_006.png" alt="Tiro
parabólico.">
<p class="caption"> <strong>Figura 4:</strong> Trayectoria de una
partícula calculada con fuerzas.bc.</p>
</div>

<p>
En la figura 4, se puede ver la trayectoria tridimensional de
una masa lanzada en un campo gravitatorio, un problema clásico
de física de bachillerato. El código <strong>bc</strong> no es
difícil de entender. Simplemente define los parámetros de la
simulación: posiciones y velocidades iniciales, tiempos iniciales
y finales, paso temporal y constantes (aceleración de la
gravedad, masa y carga). A continuación define la función
<strong>aceleraciones</strong>, que utiliza la segunda ley de
Newton para calcular las aceleraciones a partir de las fuerzas.
En general, la fuerza será una función de la posición, la
velocidad, la masa y la carga. Por último, la función
<strong>integra_ec</strong> integra las ecuaciones del
movimiento utilizando el método de pasos temporales pequeños
explicado antes y produce una lista de datos por columnas.
La primera columna presenta el instante temporal y las otras
tres las coordenadas <em>r<sub>x</sub></em>,
<em>r<sub>y</sub></em> y <em>r<sub>z</sub></em>. Utilizando
esta lista, se representó la trayectoria de la figura 4 con
el programa <strong>gnuplot</strong>.
</p>

<p>
Es muy fácil modificar el comportamiento de
<strong>fuerzas.bc</strong> para simular otro tipo de fenómenos.
Supongamos que queremos simular el movimiento de un oscilador
amortiguado. En este caso, la segunda ley de Newton es
</p>

<p class="formula">
a = <sup>d<sup>2</sup>x</sup>/<sub>dt<sup>2</sup></sub>
=  −
<em class="paren">(</em><sup>k</sup>/<sub>m</sub><em class="paren">)</em>
x −
<em class="paren">(</em><sup>c</sup>/<sub>m</sub><em class="paren">)</em>
<sup>dx</sup>/<sub>dt</sub>.
</p>

<p>
Así que, aparte de los cambios apropiados en las condiciones
iniciales, tenemos que convertir la función
<strong>aceleraciones</strong> en ésta:
</p>

<pre>    define aceleraciones(r[], v[], *a[], masa, carga) {
      a[1] = -(k/m)*r[1] -(c/m)*v[1];
      a[2] = 0;
      a[3] = 0;

      return 0;
    }
</pre>

<p>
Evidentemente, también habrá que especificar los valores de las
constantes nuevas <em>k</em> y <em>c</em>.
</p>

<div class="floatright"><img src="C%C3%A1lculo%20num%C3%A9rico%20con%20bc_files/bc.png" alt="Tiro
parabólico.">
<p class="caption"> <strong>Figura 5:</strong> Elongación
frente a tiempo para un oscilador armónico<br>
amortiguado.</p>
</div>

<p>
En la figura 5, se puede ver la gráfica de <em>x</em> frente
a <em>t</em> para un oscilador amortiguado con los siguientes
valores iniciales y constantes <em>k</em> y <em>c</em>:
</p>

<p class="formula">
r<sub>x</sub> = 1, r<sub>y</sub> = r<sub>z</sub> = 0, <br>
v<sub>x</sub> = v<sub>y</sub> = v<sub>z</sub> = 0, <br>
k = 1, c = 0,5.
</p>

<p>
La función que integra las ecuaciones del movimiento es
exactamente la misma que en el caso del lanzamiento. El lector
interesado sin duda querrá ensayar con sus propias versiones
para cometas, satélites o campos electromagnéticos.
</p>

<p>
Los principales problemas que puede presentar ahora la
dinámica de una partícula tienen que ver con la selección
de las magnitudes adecuadas (unidades y tamaño del paso de
tiempo) y escribir la ecuación para la aceleración en términos
de la posición y velocidad de la partícula. Pero hallar la
trayectoria a partir de la ecuación se ha convertido en
una tarea muy fácil.
</p>

<p>
El código <strong>fuerzas.bc</strong> presupone que sólo
se está simulando el movimiento de una partícula. Sin embargo,
no es muy difícil generalizar el método a un número arbitrario
de partículas que interactúan. Con pasos de integración adecuados,
es relativamente fácil programar un modelo numérico básico del
sistema solar, por ejemplo.
</p>

<h4 id="s4.2.2">4.2.2 Campos de fuerzas (<a href="gopher://sdf.lonestar.org/0/users/marcmmw/esp/programacion/bc/campos.bc">campos.bc</a>)</h4>

<p>
Si te encuentras en un examen con un problema en el que
tienes que calcular el campo eléctrico creado por un hilo
cargado o una superficie, o algo parecido, normalmente te
pedirán que realices el cálculo para un punto en el que las
operaciones se simplifican bastante a causa de la simetría
de la disposición de cargas.
</p>

<div class="floatright"><img src="C%C3%A1lculo%20num%C3%A9rico%20con%20bc_files/bc_005.png" alt="Tiro
parabólico.">
<p class="caption"> <strong>Figura 6:</strong> Campo
eléctrico creado por un semicírculo cargado.</p>
</div>

<p>
Por ejemplo, para el semicírculo cargado de la figura 6, lo
habitual es pedir el campo eléctrico en el centro del arco,
es decir, el punto (0, 0) de la gráfica. Pero calcular el
valor del campo en otros puntos se convierte en una tarea
bastante más tediosa. Evidentemente, la mayoría de las
aplicaciones prácticas de la electrostática exigen conocer
los campos en muchos puntos, no solo donde es fácil
calcularlos.
</p>

<p>
El código de <strong>campos.bc</strong> no es más que un
ejemplo de cómo hacer este tipo de cálculos. El resultado
se ha representado en la figura 6  usando el programa
gratuito <strong>gnuplot</strong>.
</p>

<p>
Es verdad. Todos estos cálculos se pueden hacer también
aprendiendo a manejar algún programa matemático como
Octave, Maxima, Maple o Mathematica. Pero para muchas cosas
basta una herramienta relativamente sencilla como
<strong>bc</strong>. La programación en <strong>bc</strong>
tiene el encanto del bricolaje: cuando terminas, puedes
mirar con satisfacción algo que has hecho tú. No hay ninguna
duda de que esto tiene mucho valor desde el punto de vista
didáctico, pero lo que me gustaría defender a mí es que un
ordenador "viejo" no tiene por qué suponer una limitación.
Evidentemente, no podrás jugar a los últimos juegos de
acción sin una tarjeta gráfica potente, pero la gran mayoría
de las cosas que tienes que hacer en una carrera técnica
se pueden hacer con cualquier cacharro. Si a Einstein no
le hizo falta tanta potencia de cálculo, probablemente tampoco
la necesitarás tú.
</p>

<p>
     <a rel="license" href="http://creativecommons.org/licenses/by/3.0/es/"><img alt="Creative 
Commons License" style="border-width:0" src="C%C3%A1lculo%20num%C3%A9rico%20con%20bc_files/88x31.png"></a>

    <a href="http://validator.w3.org/check?uri=referer"><img src="C%C3%A1lculo%20num%C3%A9rico%20con%20bc_files/valid-xhtml10-blue.png" alt="Valid XHTML 1.0 Strict" height="31" width="88"></a>
</p>

</div>



</body></html>